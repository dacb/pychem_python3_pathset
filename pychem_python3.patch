diff -Naur pychem-1.0/src/pychem/asa.py pychem-1.0.3/src/pychem/asa.py
--- pychem-1.0/src/pychem/asa.py	2012-11-09 08:58:45.000000000 -0800
+++ pychem-1.0.3/src/pychem/asa.py	2017-01-20 11:03:44.676668232 -0800
@@ -11,7 +11,7 @@
 
 
 import math
-from vector3d import pos_distance, Vector3d, pos_distance_sq
+from .vector3d import pos_distance, Vector3d, pos_distance_sq
 
 
 def generate_sphere_points(n):
@@ -95,5 +95,5 @@
   
 if __name__ == "__main__":
   #main()
-  print generate_sphere_points(10)
+  print(generate_sphere_points(10))
 
diff -Naur pychem-1.0/src/pychem/AtomProperty.py pychem-1.0.3/src/pychem/AtomProperty.py
--- pychem-1.0/src/pychem/AtomProperty.py	2012-09-19 06:07:34.000000000 -0700
+++ pychem-1.0.3/src/pychem/AtomProperty.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,106 +1,106 @@
-# -*- coding: utf-8 -*-
-"""
-You can freely use and distribute it. If you hava  
-
-any problem, you could contact with us timely!
-
-Created on Sun Jul 03 03:03:26 2011
-
-@author: Dongsheng Cao and Yizeng Liang.
-
-Email: oriental-cds@163.com
-
-Z: atomic number
-L: principal quantum number
-Zv: number of valence electrons
-Rv: van der Waals atomic radius
-Rc: covalent radius
-m: atomic mass
-V: van der Waals vloume
-En: Sanderson electronegativity
-alapha: atomic polarizability (10e-24 cm3)
-IP: ionization potential (eV)
-EA: electron affinity (eV)
-"""
-
-################################################################################
-AtomProperty={
-'H':{'Z':1,'L':1,'Zv':1,'Rv':1.17,'Rc':0.37,'m':1.01,'V':6.71,'En':2.59,'alapha':0.67,'IP':13.598,'EA':0.754},
-'Li':{'Z':3,'L':2,'Zv':1,'Rv':1.82,'Rc':1.34,'m':6.94,'V':25.25,'En':0.89,'alapha':24.3,'IP':5.392,'EA':0.618},
-'Be':{'Z':4,'L':2,'Zv':2,'Rv':0.0,'Rc':0.90,'m':9.01,'V':0.0,'En':1.81,'alapha':5.60,'IP':9.323,'EA':0.0},
-'B':{'Z':5,'L':2,'Zv':3,'Rv':1.62,'Rc':0.82,'m':10.81,'V':17.88,'En':2.28,'alapha':3.03,'IP':8.298,'EA':0.277},
-'C':{'Z':6,'L':2,'Zv':4,'Rv':1.75,'Rc':0.77,'m':12.01,'V':22.45,'En':2.75,'alapha':1.76,'IP':11.260,'EA':1.263},
-'N':{'Z':7,'L':2,'Zv':5,'Rv':1.55,'Rc':0.75,'m':14.01,'V':15.60,'En':3.19,'alapha':1.10,'IP':14.534,'EA':0.0},
-'O':{'Z':8,'L':2,'Zv':6,'Rv':1.40,'Rc':0.73,'m':16.00,'V':11.49,'En':3.65,'alapha':0.80,'IP':13.618,'EA':1.461},
-'F':{'Z':9,'L':2,'Zv':7,'Rv':1.30,'Rc':0.71,'m':19.00,'V':9.20,'En':4.00,'alapha':0.56,'IP':17.423,'EA':3.401},
-'Na':{'Z':11,'L':3,'Zv':1,'Rv':2.27,'Rc':1.54,'m':22.99,'V':49.00,'En':0.56,'alapha':23.6,'IP':5.139,'EA':0.548},
-'Mg':{'Z':12,'L':3,'Zv':2,'Rv':1.73,'Rc':1.30,'m':24.31,'V':21.69,'En':1.32,'alapha':10.6,'IP':7.646,'EA':0.0},
-'Al':{'Z':13,'L':3,'Zv':3,'Rv':2.06,'Rc':1.18,'m':26.98,'V':36.51,'En':1.71,'alapha':6.80,'IP':5.986,'EA':0.441},
-'Si':{'Z':14,'L':3,'Zv':4,'Rv':1.97,'Rc':1.11,'m':28.09,'V':31.98,'En':2.14,'alapha':5.38,'IP':8.152,'EA':1.385},
-'P':{'Z':15,'L':3,'Zv':5,'Rv':1.85,'Rc':1.06,'m':30.97,'V':26.52,'En':2.52,'alapha':3.63,'IP':10.487,'EA':0.747},
-'S':{'Z':16,'L':3,'Zv':6,'Rv':1.80,'Rc':1.02,'m':32.07,'V':24.43,'En':2.96,'alapha':2.90,'IP':10.360,'EA':2.077},
-'Cl':{'Z':17,'L':3,'Zv':7,'Rv':1.75,'Rc':0.99,'m':35.45,'V':22.45,'En':3.48,'alapha':2.18,'IP':12.968,'EA':3.613},
-'K':{'Z':19,'L':4,'Zv':1,'Rv':2.75,'Rc':1.96,'m':39.10,'V':87.11,'En':0.45,'alapha':43.4,'IP':4.341,'EA':0.501},
-'Ca':{'Z':20,'L':4,'Zv':2,'Rv':0.0,'Rc':1.74,'m':40.08,'V':0.0,'En':0.95,'alapha':22.8,'IP':6.113,'EA':0.018},
-'Cr':{'Z':24,'L':4,'Zv':6,'Rv':2.20,'Rc':1.27,'m':52.00,'V':44.60,'En':1.66,'alapha':11.60,'IP':6.767,'EA':0.666},
-'Mn':{'Z':25,'L':4,'Zv':7,'Rv':2.18,'Rc':1.39,'m':54.94,'V':43.40,'En':2.20,'alapha':9.40,'IP':7.434,'EA':0.0},
-'Fe':{'Z':26,'L':4,'Zv':8,'Rv':2.14,'Rc':1.25,'m':55.85,'V':41.05,'En':2.20,'alapha':8.40,'IP':7.902,'EA':1.151},
-'Co':{'Z':27,'L':4,'Zv':9,'Rv':2.03,'Rc':1.26,'m':58.93,'V':35.04,'En':2.56,'alapha':7.50,'IP':7.881,'EA':0.662},
-'Ni':{'Z':28,'L':4,'Zv':10,'Rv':1.60,'Rc':1.21,'m':58.69,'V':17.16,'En':1.94,'alapha':6.80,'IP':7.640,'EA':1.156},
-'Cu':{'Z':29,'L':4,'Zv':11,'Rv':1.40,'Rc':1.38,'m':63.55,'V':11.49,'En':1.95,'alapha':6.10,'IP':7.723,'EA':1.235},
-'Zn':{'Z':30,'L':4,'Zv':12,'Rv':1.39,'Rc':1.31,'m':65.39,'V':11.25,'En':2.23,'alapha':7.10,'IP':9.394,'EA':0.0},
-'Ga':{'Z':31,'L':4,'Zv':3,'Rv':1.87,'Rc':1.26,'m':69.72,'V':27.39,'En':2.42,'alapha':8.12,'IP':5.999,'EA':0.300},
-'Ge':{'Z':32,'L':4,'Zv':4,'Rv':1.90,'Rc':1.22,'m':72.61,'V':28.73,'En':2.62,'alapha':6.07,'IP':7.900,'EA':1.233},
-'As':{'Z':33,'L':4,'Zv':5,'Rv':1.85,'Rc':1.19,'m':74.92,'V':26.52,'En':2.82,'alapha':4.31,'IP':9.815,'EA':0.810},
-'Se':{'Z':34,'L':4,'Zv':6,'Rv':1.90,'Rc':1.16,'m':78.96,'V':28.73,'En':3.01,'alapha':3.73,'IP':9.752,'EA':2.021},
-'Br':{'Z':35,'L':4,'Zv':7,'Rv':1.95,'Rc':1.14,'m':79.90,'V':31.06,'En':3.22,'alapha':3.05,'IP':11.814,'EA':3.364},
-'Rb':{'Z':37,'L':5,'Zv':1,'Rv':0.0,'Rc':2.11,'m':85.47,'V':0.0,'En':0.31,'alapha':47.3,'IP':4.177,'EA':0.486},
-'Sr':{'Z':38,'L':5,'Zv':2,'Rv':0.0,'Rc':1.92,'m':87.62,'V':0.0,'En':0.72,'alapha':27.6,'IP':5.695,'EA':0.110},
-'Mo':{'Z':42,'L':5,'Zv':6,'Rv':2.00,'Rc':1.45,'m':95.94,'V':33.51,'En':1.15,'alapha':12.80,'IP':7.092,'EA':0.746},
-'Ag':{'Z':47,'L':5,'Zv':11,'Rv':1.72,'Rc':1.53,'m':107.87,'V':21.31,'En':1.83,'alapha':7.20,'IP':7.576,'EA':1.302},
-'Cd':{'Z':48,'L':5,'Zv':12,'Rv':1.58,'Rc':1.48,'m':112.41,'V':16.52,'En':1.98,'alapha':7.20,'IP':8.994,'EA':0.0},
-'In':{'Z':49,'L':5,'Zv':3,'Rv':1.93,'Rc':1.44,'m':114.82,'V':30.11,'En':2.14,'alapha':10.20,'IP':5.786,'EA':0.300},
-'Sn':{'Z':50,'L':5,'Zv':4,'Rv':2.22,'Rc':1.41,'m':118.71,'V':45.83,'En':2.30,'alapha':7.70,'IP':7.344,'EA':1.112},
-'Sb':{'Z':51,'L':5,'Zv':5,'Rv':2.10,'Rc':1.38,'m':121.76,'V':38.79,'En':2.46,'alapha':6.60,'IP':8.64,'EA':1.07},
-'Te':{'Z':52,'L':5,'Zv':6,'Rv':2.06,'Rc':1.35,'m':127.60,'V':36.62,'En':2.62,'alapha':5.50,'IP':9.01,'EA':1.971},
-'I':{'Z':53,'L':5,'Zv':7,'Rv':2.10,'Rc':1.33,'m':126.90,'V':38.79,'En':2.78,'alapha':5.35,'IP':10.451,'EA':3.059},
-'Gd':{'Z':64,'L':6,'Zv':10,'Rv':2.59,'Rc':1.79,'m':157.25,'V':72.78,'En':2.00,'alapha':23.50,'IP':6.15,'EA':0.50},
-'Pt':{'Z':78,'L':6,'Zv':10,'Rv':1.75,'Rc':1.28,'m':195.08,'V':22.45,'En':2.28,'alapha':6.50,'IP':9.00,'EA':2.128},
-'Au':{'Z':79,'L':6,'Zv':11,'Rv':1.66,'Rc':1.44,'m':196.97,'V':19.16,'En':2.65,'alapha':5.80,'IP':9.226,'EA':2.309},
-'Hg':{'Z':80,'L':6,'Zv':12,'Rv':1.55,'Rc':1.49,'m':200.59,'V':15.60,'En':2.20,'alapha':5.70,'IP':10.438,'EA':0.0},
-'Tl':{'Z':81,'L':6,'Zv':3,'Rv':1.96,'Rc':1.48,'m':204.38,'V':31.54,'En':2.25,'alapha':7.60,'IP':6.108,'EA':0.200},
-'Pb':{'Z':82,'L':6,'Zv':4,'Rv':2.02,'Rc':1.47,'m':207.20,'V':34.53,'En':2.29,'alapha':6.80,'IP':7.417,'EA':0.364},
-'Bi':{'Z':83,'L':6,'Zv':5,'Rv':2.10,'Rc':1.46,'m':208.98,'V':38.79,'En':2.34,'alapha':7.40,'IP':7.289,'EA':0.946},
-
-}
-
-
-
-def GetAbsoluteAtomicProperty(element='C',propertyname='m'):
-    """
-    Get the absolute property value with propertyname for the given atom.
-    """
-    
-    PropertyDic=AtomProperty[element]
-    
-    return PropertyDic[propertyname]
-
-
-def GetRelativeAtomicProperty(element='C',propertyname='m'):
-    """
-    Get the absolute property value with propertyname for the given atom.
-    """
-    
-    CpropertyDic=AtomProperty['C']
-    PropertyDic=AtomProperty[element]
-    
-    return PropertyDic[propertyname]/(CpropertyDic[propertyname]+0.0)
-
-###############################################################################
-
-if __name__=="__main__":
-    
-    for i,j in AtomProperty.items():
-        print j
-    print GetAbsoluteAtomicProperty(element='S',propertyname='En')
-    print GetRelativeAtomicProperty(element='S',propertyname='En')
+# -*- coding: utf-8 -*-
+"""
+You can freely use and distribute it. If you hava  
+
+any problem, you could contact with us timely!
+
+Created on Sun Jul 03 03:03:26 2011
+
+@author: Dongsheng Cao and Yizeng Liang.
+
+Email: oriental-cds@163.com
+
+Z: atomic number
+L: principal quantum number
+Zv: number of valence electrons
+Rv: van der Waals atomic radius
+Rc: covalent radius
+m: atomic mass
+V: van der Waals vloume
+En: Sanderson electronegativity
+alapha: atomic polarizability (10e-24 cm3)
+IP: ionization potential (eV)
+EA: electron affinity (eV)
+"""
+
+################################################################################
+AtomProperty={
+'H':{'Z':1,'L':1,'Zv':1,'Rv':1.17,'Rc':0.37,'m':1.01,'V':6.71,'En':2.59,'alapha':0.67,'IP':13.598,'EA':0.754},
+'Li':{'Z':3,'L':2,'Zv':1,'Rv':1.82,'Rc':1.34,'m':6.94,'V':25.25,'En':0.89,'alapha':24.3,'IP':5.392,'EA':0.618},
+'Be':{'Z':4,'L':2,'Zv':2,'Rv':0.0,'Rc':0.90,'m':9.01,'V':0.0,'En':1.81,'alapha':5.60,'IP':9.323,'EA':0.0},
+'B':{'Z':5,'L':2,'Zv':3,'Rv':1.62,'Rc':0.82,'m':10.81,'V':17.88,'En':2.28,'alapha':3.03,'IP':8.298,'EA':0.277},
+'C':{'Z':6,'L':2,'Zv':4,'Rv':1.75,'Rc':0.77,'m':12.01,'V':22.45,'En':2.75,'alapha':1.76,'IP':11.260,'EA':1.263},
+'N':{'Z':7,'L':2,'Zv':5,'Rv':1.55,'Rc':0.75,'m':14.01,'V':15.60,'En':3.19,'alapha':1.10,'IP':14.534,'EA':0.0},
+'O':{'Z':8,'L':2,'Zv':6,'Rv':1.40,'Rc':0.73,'m':16.00,'V':11.49,'En':3.65,'alapha':0.80,'IP':13.618,'EA':1.461},
+'F':{'Z':9,'L':2,'Zv':7,'Rv':1.30,'Rc':0.71,'m':19.00,'V':9.20,'En':4.00,'alapha':0.56,'IP':17.423,'EA':3.401},
+'Na':{'Z':11,'L':3,'Zv':1,'Rv':2.27,'Rc':1.54,'m':22.99,'V':49.00,'En':0.56,'alapha':23.6,'IP':5.139,'EA':0.548},
+'Mg':{'Z':12,'L':3,'Zv':2,'Rv':1.73,'Rc':1.30,'m':24.31,'V':21.69,'En':1.32,'alapha':10.6,'IP':7.646,'EA':0.0},
+'Al':{'Z':13,'L':3,'Zv':3,'Rv':2.06,'Rc':1.18,'m':26.98,'V':36.51,'En':1.71,'alapha':6.80,'IP':5.986,'EA':0.441},
+'Si':{'Z':14,'L':3,'Zv':4,'Rv':1.97,'Rc':1.11,'m':28.09,'V':31.98,'En':2.14,'alapha':5.38,'IP':8.152,'EA':1.385},
+'P':{'Z':15,'L':3,'Zv':5,'Rv':1.85,'Rc':1.06,'m':30.97,'V':26.52,'En':2.52,'alapha':3.63,'IP':10.487,'EA':0.747},
+'S':{'Z':16,'L':3,'Zv':6,'Rv':1.80,'Rc':1.02,'m':32.07,'V':24.43,'En':2.96,'alapha':2.90,'IP':10.360,'EA':2.077},
+'Cl':{'Z':17,'L':3,'Zv':7,'Rv':1.75,'Rc':0.99,'m':35.45,'V':22.45,'En':3.48,'alapha':2.18,'IP':12.968,'EA':3.613},
+'K':{'Z':19,'L':4,'Zv':1,'Rv':2.75,'Rc':1.96,'m':39.10,'V':87.11,'En':0.45,'alapha':43.4,'IP':4.341,'EA':0.501},
+'Ca':{'Z':20,'L':4,'Zv':2,'Rv':0.0,'Rc':1.74,'m':40.08,'V':0.0,'En':0.95,'alapha':22.8,'IP':6.113,'EA':0.018},
+'Cr':{'Z':24,'L':4,'Zv':6,'Rv':2.20,'Rc':1.27,'m':52.00,'V':44.60,'En':1.66,'alapha':11.60,'IP':6.767,'EA':0.666},
+'Mn':{'Z':25,'L':4,'Zv':7,'Rv':2.18,'Rc':1.39,'m':54.94,'V':43.40,'En':2.20,'alapha':9.40,'IP':7.434,'EA':0.0},
+'Fe':{'Z':26,'L':4,'Zv':8,'Rv':2.14,'Rc':1.25,'m':55.85,'V':41.05,'En':2.20,'alapha':8.40,'IP':7.902,'EA':1.151},
+'Co':{'Z':27,'L':4,'Zv':9,'Rv':2.03,'Rc':1.26,'m':58.93,'V':35.04,'En':2.56,'alapha':7.50,'IP':7.881,'EA':0.662},
+'Ni':{'Z':28,'L':4,'Zv':10,'Rv':1.60,'Rc':1.21,'m':58.69,'V':17.16,'En':1.94,'alapha':6.80,'IP':7.640,'EA':1.156},
+'Cu':{'Z':29,'L':4,'Zv':11,'Rv':1.40,'Rc':1.38,'m':63.55,'V':11.49,'En':1.95,'alapha':6.10,'IP':7.723,'EA':1.235},
+'Zn':{'Z':30,'L':4,'Zv':12,'Rv':1.39,'Rc':1.31,'m':65.39,'V':11.25,'En':2.23,'alapha':7.10,'IP':9.394,'EA':0.0},
+'Ga':{'Z':31,'L':4,'Zv':3,'Rv':1.87,'Rc':1.26,'m':69.72,'V':27.39,'En':2.42,'alapha':8.12,'IP':5.999,'EA':0.300},
+'Ge':{'Z':32,'L':4,'Zv':4,'Rv':1.90,'Rc':1.22,'m':72.61,'V':28.73,'En':2.62,'alapha':6.07,'IP':7.900,'EA':1.233},
+'As':{'Z':33,'L':4,'Zv':5,'Rv':1.85,'Rc':1.19,'m':74.92,'V':26.52,'En':2.82,'alapha':4.31,'IP':9.815,'EA':0.810},
+'Se':{'Z':34,'L':4,'Zv':6,'Rv':1.90,'Rc':1.16,'m':78.96,'V':28.73,'En':3.01,'alapha':3.73,'IP':9.752,'EA':2.021},
+'Br':{'Z':35,'L':4,'Zv':7,'Rv':1.95,'Rc':1.14,'m':79.90,'V':31.06,'En':3.22,'alapha':3.05,'IP':11.814,'EA':3.364},
+'Rb':{'Z':37,'L':5,'Zv':1,'Rv':0.0,'Rc':2.11,'m':85.47,'V':0.0,'En':0.31,'alapha':47.3,'IP':4.177,'EA':0.486},
+'Sr':{'Z':38,'L':5,'Zv':2,'Rv':0.0,'Rc':1.92,'m':87.62,'V':0.0,'En':0.72,'alapha':27.6,'IP':5.695,'EA':0.110},
+'Mo':{'Z':42,'L':5,'Zv':6,'Rv':2.00,'Rc':1.45,'m':95.94,'V':33.51,'En':1.15,'alapha':12.80,'IP':7.092,'EA':0.746},
+'Ag':{'Z':47,'L':5,'Zv':11,'Rv':1.72,'Rc':1.53,'m':107.87,'V':21.31,'En':1.83,'alapha':7.20,'IP':7.576,'EA':1.302},
+'Cd':{'Z':48,'L':5,'Zv':12,'Rv':1.58,'Rc':1.48,'m':112.41,'V':16.52,'En':1.98,'alapha':7.20,'IP':8.994,'EA':0.0},
+'In':{'Z':49,'L':5,'Zv':3,'Rv':1.93,'Rc':1.44,'m':114.82,'V':30.11,'En':2.14,'alapha':10.20,'IP':5.786,'EA':0.300},
+'Sn':{'Z':50,'L':5,'Zv':4,'Rv':2.22,'Rc':1.41,'m':118.71,'V':45.83,'En':2.30,'alapha':7.70,'IP':7.344,'EA':1.112},
+'Sb':{'Z':51,'L':5,'Zv':5,'Rv':2.10,'Rc':1.38,'m':121.76,'V':38.79,'En':2.46,'alapha':6.60,'IP':8.64,'EA':1.07},
+'Te':{'Z':52,'L':5,'Zv':6,'Rv':2.06,'Rc':1.35,'m':127.60,'V':36.62,'En':2.62,'alapha':5.50,'IP':9.01,'EA':1.971},
+'I':{'Z':53,'L':5,'Zv':7,'Rv':2.10,'Rc':1.33,'m':126.90,'V':38.79,'En':2.78,'alapha':5.35,'IP':10.451,'EA':3.059},
+'Gd':{'Z':64,'L':6,'Zv':10,'Rv':2.59,'Rc':1.79,'m':157.25,'V':72.78,'En':2.00,'alapha':23.50,'IP':6.15,'EA':0.50},
+'Pt':{'Z':78,'L':6,'Zv':10,'Rv':1.75,'Rc':1.28,'m':195.08,'V':22.45,'En':2.28,'alapha':6.50,'IP':9.00,'EA':2.128},
+'Au':{'Z':79,'L':6,'Zv':11,'Rv':1.66,'Rc':1.44,'m':196.97,'V':19.16,'En':2.65,'alapha':5.80,'IP':9.226,'EA':2.309},
+'Hg':{'Z':80,'L':6,'Zv':12,'Rv':1.55,'Rc':1.49,'m':200.59,'V':15.60,'En':2.20,'alapha':5.70,'IP':10.438,'EA':0.0},
+'Tl':{'Z':81,'L':6,'Zv':3,'Rv':1.96,'Rc':1.48,'m':204.38,'V':31.54,'En':2.25,'alapha':7.60,'IP':6.108,'EA':0.200},
+'Pb':{'Z':82,'L':6,'Zv':4,'Rv':2.02,'Rc':1.47,'m':207.20,'V':34.53,'En':2.29,'alapha':6.80,'IP':7.417,'EA':0.364},
+'Bi':{'Z':83,'L':6,'Zv':5,'Rv':2.10,'Rc':1.46,'m':208.98,'V':38.79,'En':2.34,'alapha':7.40,'IP':7.289,'EA':0.946},
+
+}
+
+
+
+def GetAbsoluteAtomicProperty(element='C',propertyname='m'):
+    """
+    Get the absolute property value with propertyname for the given atom.
+    """
+    
+    PropertyDic=AtomProperty[element]
+    
+    return PropertyDic[propertyname]
+
+
+def GetRelativeAtomicProperty(element='C',propertyname='m'):
+    """
+    Get the absolute property value with propertyname for the given atom.
+    """
+    
+    CpropertyDic=AtomProperty['C']
+    PropertyDic=AtomProperty[element]
+    
+    return PropertyDic[propertyname]/(CpropertyDic[propertyname]+0.0)
+
+###############################################################################
+
+if __name__=="__main__":
+    
+    for i,j in AtomProperty.items():
+        print(j)
+    print(GetAbsoluteAtomicProperty(element='S',propertyname='En'))
+    print(GetRelativeAtomicProperty(element='S',propertyname='En'))
diff -Naur pychem-1.0/src/pychem/basak.py pychem-1.0.3/src/pychem/basak.py
--- pychem-1.0/src/pychem/basak.py	2012-11-14 05:38:49.000000000 -0800
+++ pychem-1.0.3/src/pychem/basak.py	2017-01-20 11:03:44.676668232 -0800
@@ -538,7 +538,7 @@
     smi5=['CCCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N']
     for index, smi in enumerate(smi5):
         m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',Getbasak(m)
-        print len(Getbasak(m))
+        print(index+1)
+        print(smi)      
+        print('\t',Getbasak(m))
+        print(len(Getbasak(m)))
diff -Naur pychem-1.0/src/pychem/bcut.py pychem-1.0.3/src/pychem/bcut.py
--- pychem-1.0/src/pychem/bcut.py	2012-11-14 05:38:39.000000000 -0800
+++ pychem-1.0.3/src/pychem/bcut.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,227 +1,227 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-
-The calculation of Burden eigvenvalue descriptors. You can get 64
-
-molecular decriptors. You can freely use and distribute it. If you hava  
-
-any problem, you could contact with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.09.18
-
-Email: oriental-cds@163.com
-
-##############################################################################
-"""
-
-from rdkit import Chem
-from AtomProperty import GetRelativeAtomicProperty
-
-import numpy
-import numpy.linalg
-
-
-Version=1.0
-################################################################
-
-def _GetBurdenMatrix(mol,propertylabel='m'):
-    """
-    #################################################################
-    *Internal used only**
-    
-    Calculate Burden matrix and their eigenvalues.
-    #################################################################
-    """
-    mol=Chem.AddHs(mol)
-    Natom=mol.GetNumAtoms()
-
-    AdMatrix=Chem.GetAdjacencyMatrix(mol)
-    bondindex=numpy.argwhere(AdMatrix)
-    AdMatrix1=numpy.array(AdMatrix,dtype=numpy.float32)
-    
-    #The diagonal elements of B, Bii, are either given by 
-    #the carbon normalized atomic mass,
-    #van der Waals volume, Sanderson electronegativity,
-    #and polarizability of atom i.
-
-    for i in range(Natom):
-        atom=mol.GetAtomWithIdx(i)
-        temp=GetRelativeAtomicProperty(element=atom.GetSymbol(),propertyname=propertylabel)
-        AdMatrix1[i,i]=round(temp,3)
-        
-    #The element of B connecting atoms i and j, Bij, 
-    #is equal to the square root of the bond
-    #order between atoms i and j.
-    
-    for i in bondindex:
-        bond=mol.GetBondBetweenAtoms(int(i[0]),int(i[1]))
-        if bond.GetBondType().name =='SINGLE':
-            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(1),3)
-        if bond.GetBondType().name=="DOUBLE":
-            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(2),3)
-        if bond.GetBondType().name=="TRIPLE":
-            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(3),3)
-        if bond.GetBondType().name=="AROMATIC":
-            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(1.5),3)
-    
-    ##All other elements of B (corresponding non bonded 
-    #atom pairs) are set to 0.001       
-    bondnonindex=numpy.argwhere(AdMatrix==0)
-    
-    for i in bondnonindex:
-        if i[0]!=i[1]:
-            
-            AdMatrix1[i[0],i[1]]=0.001  
-     
-    return numpy.real(numpy.linalg.eigvals(AdMatrix1))
-    
-    
-
-def CalculateBurdenMass(mol):
-    """
-    #################################################################
-    Calculate Burden descriptors based on atomic mass.
-    
-    res--->dict type with 16 descriptors
-    #################################################################
-    """
-    temp=_GetBurdenMatrix(mol,propertylabel='m')
-    temp1=numpy.sort(temp[temp>=0])
-    temp2=numpy.sort(numpy.abs(temp[temp<0]))
-    
-    if len(temp1)<8:
-        temp1=numpy.concatenate((numpy.zeros(8),temp1))
-    if len(temp2)<8:
-        temp2=numpy.concatenate((numpy.zeros(8),temp2))
-    
-    bcut=["bcutm16","bcutm15","bcutm14","bcutm13","bcutm12","bcutm11","bcutm10",
-          "bcutm9","bcutm8","bcutm7","bcutm6","bcutm5","bcutm4","bcutm3",
-          "bcutm2","bcutm1"]
-    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
-    
-    bcutvalue=[round(i,3) for i in bcutvalue]
-    res=dict(zip(bcut,bcutvalue))
-    return res
-
-        
-
-def CalculateBurdenVDW(mol):
-    """
-    #################################################################
-    Calculate Burden descriptors based on atomic vloumes
-    
-    res-->dict type with 16 descriptors
-    #################################################################
-    """
-    temp=_GetBurdenMatrix(mol,propertylabel='V')
-    temp1=numpy.sort(temp[temp>=0])
-    temp2=numpy.sort(numpy.abs(temp[temp<0]))
-    
-    if len(temp1)<8:
-        temp1=numpy.concatenate((numpy.zeros(8),temp1))
-    if len(temp2)<8:
-        temp2=numpy.concatenate((numpy.zeros(8),temp2))
-    
-    bcut=["bcutv16","bcutv15","bcutv14","bcutv13","bcutv12","bcutv11","bcutv10",
-          "bcutv9","bcutv8","bcutv7","bcutv6","bcutv5","bcutv4","bcutv3",
-          "bcutv2","bcutv1"]
-    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
-    
-    bcutvalue=[round(i,3) for i in bcutvalue]
-    res=dict(zip(bcut,bcutvalue))
-    return res
-
-
-
-def CalculateBurdenElectronegativity(mol):
-    """
-    #################################################################
-    Calculate Burden descriptors based on atomic electronegativity.
-    
-    res-->dict type with 16 descriptors
-    #################################################################
-    """
-    temp=_GetBurdenMatrix(mol,propertylabel='En')
-    temp1=numpy.sort(temp[temp>=0])
-    temp2=numpy.sort(numpy.abs(temp[temp<0]))
-    
-    if len(temp1)<8:
-        temp1=numpy.concatenate((numpy.zeros(8),temp1))
-    if len(temp2)<8:
-        temp2=numpy.concatenate((numpy.zeros(8),temp2))
-    
-    bcut=["bcute16","bcute15","bcute14","bcute13","bcute12","bcute11","bcute10",
-          "bcute9","bcute8","bcute7","bcute6","bcute5","bcute4","bcute3",
-          "bcute2","bcute1"]
-    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
-    
-    bcutvalue=[round(i,3) for i in bcutvalue]
-    res=dict(zip(bcut,bcutvalue))
-    return res
-
-
-def CalculateBurdenPolarizability(mol):
-    """
-    #################################################################
-    Calculate Burden descriptors based on polarizability.
-    
-    res-->dict type with 16 descriptors
-    #################################################################
-    """
-    temp=_GetBurdenMatrix(mol,propertylabel='alapha')
-    temp1=numpy.sort(temp[temp>=0])
-    temp2=numpy.sort(numpy.abs(temp[temp<0]))
-    
-    if len(temp1)<8:
-        temp1=numpy.concatenate((numpy.zeros(8),temp1))
-    if len(temp2)<8:
-        temp2=numpy.concatenate((numpy.zeros(8),temp2))
-    
-    bcut=["bcutp16","bcutp15","bcutp14","bcutp13","bcutp12","bcutp11","bcutp10",
-          "bcutp9","bcutp8","bcutp7","bcutp6","bcutp5","bcutp4","bcutp3",
-          "bcutp2","bcutp1"]
-    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
-    
-    bcutvalue=[round(i,3) for i in bcutvalue]
-    res=dict(zip(bcut,bcutvalue))
-    return res
-
-
-def GetBurden(mol):
-    """
-    #################################################################
-    Calculate all 64 Burden descriptors
-    
-    res-->dict type
-    #################################################################
-    """
-    bcut={}
-    bcut.update(CalculateBurdenMass(mol))
-    bcut.update(CalculateBurdenVDW(mol))
-    bcut.update(CalculateBurdenElectronegativity(mol))
-    bcut.update(CalculateBurdenPolarizability(mol))
-    return bcut
-
-
-def _GetHTMLDoc():
-    """
-    #################################################################
-    Write HTML documentation for this module.
-    #################################################################
-    """
-    import pydoc
-    pydoc.writedoc('bcut')  
-########################################################################
-
-if __name__ =='__main__':
-    
-    smi5=['CCOCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N','C']
-    for index, smi in enumerate(smi5):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi, '\n'   
-        print GetBurden(m)
-        print len(GetBurden(m))
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+
+The calculation of Burden eigvenvalue descriptors. You can get 64
+
+molecular decriptors. You can freely use and distribute it. If you hava  
+
+any problem, you could contact with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.09.18
+
+Email: oriental-cds@163.com
+
+##############################################################################
+"""
+
+from rdkit import Chem
+from .AtomProperty import GetRelativeAtomicProperty
+
+import numpy
+import numpy.linalg
+
+
+Version=1.0
+################################################################
+
+def _GetBurdenMatrix(mol,propertylabel='m'):
+    """
+    #################################################################
+    *Internal used only**
+    
+    Calculate Burden matrix and their eigenvalues.
+    #################################################################
+    """
+    mol=Chem.AddHs(mol)
+    Natom=mol.GetNumAtoms()
+
+    AdMatrix=Chem.GetAdjacencyMatrix(mol)
+    bondindex=numpy.argwhere(AdMatrix)
+    AdMatrix1=numpy.array(AdMatrix,dtype=numpy.float32)
+    
+    #The diagonal elements of B, Bii, are either given by 
+    #the carbon normalized atomic mass,
+    #van der Waals volume, Sanderson electronegativity,
+    #and polarizability of atom i.
+
+    for i in range(Natom):
+        atom=mol.GetAtomWithIdx(i)
+        temp=GetRelativeAtomicProperty(element=atom.GetSymbol(),propertyname=propertylabel)
+        AdMatrix1[i,i]=round(temp,3)
+        
+    #The element of B connecting atoms i and j, Bij, 
+    #is equal to the square root of the bond
+    #order between atoms i and j.
+    
+    for i in bondindex:
+        bond=mol.GetBondBetweenAtoms(int(i[0]),int(i[1]))
+        if bond.GetBondType().name =='SINGLE':
+            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(1),3)
+        if bond.GetBondType().name=="DOUBLE":
+            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(2),3)
+        if bond.GetBondType().name=="TRIPLE":
+            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(3),3)
+        if bond.GetBondType().name=="AROMATIC":
+            AdMatrix1[i[0],i[1]]=round(numpy.sqrt(1.5),3)
+    
+    ##All other elements of B (corresponding non bonded 
+    #atom pairs) are set to 0.001       
+    bondnonindex=numpy.argwhere(AdMatrix==0)
+    
+    for i in bondnonindex:
+        if i[0]!=i[1]:
+            
+            AdMatrix1[i[0],i[1]]=0.001  
+     
+    return numpy.real(numpy.linalg.eigvals(AdMatrix1))
+    
+    
+
+def CalculateBurdenMass(mol):
+    """
+    #################################################################
+    Calculate Burden descriptors based on atomic mass.
+    
+    res--->dict type with 16 descriptors
+    #################################################################
+    """
+    temp=_GetBurdenMatrix(mol,propertylabel='m')
+    temp1=numpy.sort(temp[temp>=0])
+    temp2=numpy.sort(numpy.abs(temp[temp<0]))
+    
+    if len(temp1)<8:
+        temp1=numpy.concatenate((numpy.zeros(8),temp1))
+    if len(temp2)<8:
+        temp2=numpy.concatenate((numpy.zeros(8),temp2))
+    
+    bcut=["bcutm16","bcutm15","bcutm14","bcutm13","bcutm12","bcutm11","bcutm10",
+          "bcutm9","bcutm8","bcutm7","bcutm6","bcutm5","bcutm4","bcutm3",
+          "bcutm2","bcutm1"]
+    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
+    
+    bcutvalue=[round(i,3) for i in bcutvalue]
+    res=dict(zip(bcut,bcutvalue))
+    return res
+
+        
+
+def CalculateBurdenVDW(mol):
+    """
+    #################################################################
+    Calculate Burden descriptors based on atomic vloumes
+    
+    res-->dict type with 16 descriptors
+    #################################################################
+    """
+    temp=_GetBurdenMatrix(mol,propertylabel='V')
+    temp1=numpy.sort(temp[temp>=0])
+    temp2=numpy.sort(numpy.abs(temp[temp<0]))
+    
+    if len(temp1)<8:
+        temp1=numpy.concatenate((numpy.zeros(8),temp1))
+    if len(temp2)<8:
+        temp2=numpy.concatenate((numpy.zeros(8),temp2))
+    
+    bcut=["bcutv16","bcutv15","bcutv14","bcutv13","bcutv12","bcutv11","bcutv10",
+          "bcutv9","bcutv8","bcutv7","bcutv6","bcutv5","bcutv4","bcutv3",
+          "bcutv2","bcutv1"]
+    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
+    
+    bcutvalue=[round(i,3) for i in bcutvalue]
+    res=dict(zip(bcut,bcutvalue))
+    return res
+
+
+
+def CalculateBurdenElectronegativity(mol):
+    """
+    #################################################################
+    Calculate Burden descriptors based on atomic electronegativity.
+    
+    res-->dict type with 16 descriptors
+    #################################################################
+    """
+    temp=_GetBurdenMatrix(mol,propertylabel='En')
+    temp1=numpy.sort(temp[temp>=0])
+    temp2=numpy.sort(numpy.abs(temp[temp<0]))
+    
+    if len(temp1)<8:
+        temp1=numpy.concatenate((numpy.zeros(8),temp1))
+    if len(temp2)<8:
+        temp2=numpy.concatenate((numpy.zeros(8),temp2))
+    
+    bcut=["bcute16","bcute15","bcute14","bcute13","bcute12","bcute11","bcute10",
+          "bcute9","bcute8","bcute7","bcute6","bcute5","bcute4","bcute3",
+          "bcute2","bcute1"]
+    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
+    
+    bcutvalue=[round(i,3) for i in bcutvalue]
+    res=dict(zip(bcut,bcutvalue))
+    return res
+
+
+def CalculateBurdenPolarizability(mol):
+    """
+    #################################################################
+    Calculate Burden descriptors based on polarizability.
+    
+    res-->dict type with 16 descriptors
+    #################################################################
+    """
+    temp=_GetBurdenMatrix(mol,propertylabel='alapha')
+    temp1=numpy.sort(temp[temp>=0])
+    temp2=numpy.sort(numpy.abs(temp[temp<0]))
+    
+    if len(temp1)<8:
+        temp1=numpy.concatenate((numpy.zeros(8),temp1))
+    if len(temp2)<8:
+        temp2=numpy.concatenate((numpy.zeros(8),temp2))
+    
+    bcut=["bcutp16","bcutp15","bcutp14","bcutp13","bcutp12","bcutp11","bcutp10",
+          "bcutp9","bcutp8","bcutp7","bcutp6","bcutp5","bcutp4","bcutp3",
+          "bcutp2","bcutp1"]
+    bcutvalue=numpy.concatenate((temp2[-8:],temp1[-8:]))
+    
+    bcutvalue=[round(i,3) for i in bcutvalue]
+    res=dict(zip(bcut,bcutvalue))
+    return res
+
+
+def GetBurden(mol):
+    """
+    #################################################################
+    Calculate all 64 Burden descriptors
+    
+    res-->dict type
+    #################################################################
+    """
+    bcut={}
+    bcut.update(CalculateBurdenMass(mol))
+    bcut.update(CalculateBurdenVDW(mol))
+    bcut.update(CalculateBurdenElectronegativity(mol))
+    bcut.update(CalculateBurdenPolarizability(mol))
+    return bcut
+
+
+def _GetHTMLDoc():
+    """
+    #################################################################
+    Write HTML documentation for this module.
+    #################################################################
+    """
+    import pydoc
+    pydoc.writedoc('bcut')  
+########################################################################
+
+if __name__ =='__main__':
+    
+    smi5=['CCOCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N','C']
+    for index, smi in enumerate(smi5):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi, '\n')   
+        print(GetBurden(m))
+        print(len(GetBurden(m)))
diff -Naur pychem-1.0/src/pychem/charge.py pychem-1.0.3/src/pychem/charge.py
--- pychem-1.0/src/pychem/charge.py	2012-11-16 23:02:24.000000000 -0800
+++ pychem-1.0.3/src/pychem/charge.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,738 +1,738 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-
-The calculation of Charge descriptors based on Gasteiger/Marseli partial 
-
-charges(25). You can freely use and distribute it. If you hava  any problem, 
-
-you could contact with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.09.18
-
-Email: oriental-cds@163.com
-
-##############################################################################
-"""
-from rdkit import Chem
-from rdkit.Chem import rdPartialCharges as GMCharge
-
-import numpy
-
-Version=1.0
-##############################################################################
-iter_step=12
-
-def _CalculateElementMaxPCharge(mol,AtomicNum=6):
-    """
-    #################################################################
-    **Internal used only**
-    
-    Most positive charge on atom with atomic number equal to n
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-        if atom.GetAtomicNum()==AtomicNum:
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        return round(max(res),3)
-
-def _CalculateElementMaxNCharge(mol,AtomicNum=6):
-    """
-    #################################################################
-    **Internal used only**
-    
-    Most negative charge on atom with atomic number equal to n
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-        if atom.GetAtomicNum()==AtomicNum:
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-    if res==[]:
-        return 0
-    else:
-        return round(min(res),3)
-
-
-def CalculateHMaxPCharge(mol):
-    """
-    #################################################################
-    Most positive charge on H atoms
-    
-    -->QHmax
-    
-    Usage:
-    
-        result=CalculateHMaxPCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxPCharge(mol,AtomicNum=1)
-
-
-def CalculateCMaxPCharge(mol):
-    """
-    #################################################################
-    Most positive charge on C atoms
-    
-    -->QCmax
-
-    Usage:
-    
-        result=CalculateCMaxPCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxPCharge(mol,AtomicNum=6)
-
-
-def CalculateNMaxPCharge(mol):
-    """
-    #################################################################
-    Most positive charge on N atoms
-    
-    -->QNmax
-
-    Usage:
-    
-        result=CalculateNMaxPCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxPCharge(mol,AtomicNum=7)
-
-
-def CalculateOMaxPCharge(mol):
-    """
-    #################################################################
-    Most positive charge on O atoms
-    
-    -->QOmax
-
-    Usage:
-    
-        result=CalculateOMaxPCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxPCharge(mol,AtomicNum=8)
-
-def CalculateHMaxNCharge(mol):
-    """
-    #################################################################
-    Most negative charge on H atoms
-  
-    -->QHmin
-
-    Usage:
-    
-        result=CalculateHMaxNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxNCharge(mol,AtomicNum=1)
-
-
-def CalculateCMaxNCharge(mol):
-    """
-    #################################################################
-    Most negative charge on C atoms
-    
-    -->QCmin
-
-    Usage:
-    
-        result=CalculateCMaxNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxNCharge(mol,AtomicNum=6)
-
-
-def CalculateNMaxNCharge(mol):
-    """
-    #################################################################
-    Most negative charge on N atoms
-    
-    -->QNmin
-
-    Usage:
-    
-        result=CalculateNMaxNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxNCharge(mol,AtomicNum=7)
-
-
-def CalculateOMaxNCharge(mol):
-    """
-    #################################################################
-    Most negative charge on O atoms
-    
-    -->QOmin
-
-    Usage:
-    
-        result=CalculateOMaxNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementMaxNCharge(mol,AtomicNum=8)
-
-def CalculateAllMaxPCharge(mol):
-    """
-    #################################################################
-    Most positive charge on ALL atoms
-    
-    -->Qmax
-
-    Usage:
-    
-        result=CalculateAllMaxPCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-    if res==[]:
-        return 0
-    else:
-        return round(max(res),3)
-
-
-def CalculateAllMaxNCharge(mol):
-    """
-    #################################################################
-    Most negative charge on all atoms
-    
-    -->Qmin
-
-    Usage:
-    
-        result=CalculateAllMaxNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-    if res==[]:
-        return 0
-    else:
-        return round(min(res),3)
-
-
-def _CalculateElementSumSquareCharge(mol,AtomicNum=6):
-    """
-    #################################################################
-    **Internal used only**
-    
-    Ths sum of square Charges on all atoms with atomicnumber equal to n
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-        if atom.GetAtomicNum()==AtomicNum:
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-    if res==[]:
-        return 0
-    else:
-        return round(sum(numpy.square(res)),3)
-
-
-def CalculateHSumSquareCharge(mol):
-    
-    """
-    #################################################################
-    The sum of square charges on all H atoms
-    
-    -->QHss
-
-    Usage:
-    
-        result=CalculateHSumSquareCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementSumSquareCharge(mol,AtomicNum=1)
-
-
-def CalculateCSumSquareCharge(mol):
-    """
-    #################################################################
-    The sum of square charges on all C atoms
-    
-    -->QCss
-
-    Usage:
-    
-        result=CalculateCSumSquareCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementSumSquareCharge(mol,AtomicNum=6)
-
-
-def CalculateNSumSquareCharge(mol):
-    """
-    #################################################################
-    The sum of square charges on all N atoms
-    
-    -->QNss
-
-    Usage:
-    
-        result=CalculateNSumSquareCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementSumSquareCharge(mol,AtomicNum=7)
-
-def CalculateOSumSquareCharge(mol):
-    """
-    #################################################################
-    The sum of square charges on all O atoms
-    
-    -->QOss
-
-    Usage:
-    
-        result=CalculateOSumSquareCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementSumSquareCharge(mol,AtomicNum=8)
-
-def CalculateAllSumSquareCharge(mol):
-    """
-    #################################################################
-    The sum of square charges on all atoms
-    
-    -->Qass
-
-    Usage:
-    
-        result=CalculateAllSumSquareCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        return round(sum(numpy.square(res)),3)
-
-def CalculateTotalPCharge(mol):
-    """
-    #################################################################
-    The total postive charge
-    
-    -->Tpc
-
-    Usage:
-    
-        result=CalculateTotalPCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        return round(sum(cc[cc>0]),3)
-
-def CalculateMeanPCharge(mol):
-    """
-    #################################################################
-    The average postive charge
-    
-    -->Mpc
-    
-    Usage:
-    
-        result=CalculateMeanPCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        return round(numpy.mean(cc[cc>0]),3)
-
-
-def CalculateTotalNCharge(mol):
-    """
-    #################################################################
-    The total negative charge
-    
-    -->Tnc
-    
-    Usage:
-    
-        result=CalculateTotalNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        return round(sum(cc[cc<0]),3)
-
-
-def CalculateMeanNCharge(mol):
-    """
-    #################################################################
-    The average negative charge
-    
-    -->Mnc
-    
-    Usage:
-    
-        result=CalculateMeanNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        return round(numpy.mean(cc[cc<0]),3)
-
-
-def CalculateTotalAbsoulteCharge(mol):
-    """
-    #################################################################
-    The total absolute charge
-    
-    -->Tac
-    
-    Usage:
-    
-        result=CalculateTotalAbsoulteCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        return round(sum(numpy.absolute(cc)),3)
-
-def CalculateMeanAbsoulteCharge(mol):
-    """
-    #################################################################
-    The average absolute charge
-    
-    -->Mac
-    
-    Usage:
-    
-        result=CalculateMeanAbsoulteCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        return round(numpy.mean(numpy.absolute(cc)),3)
-
-def CalculateRelativePCharge(mol):
-    """
-    #################################################################
-    The partial charge of the most positive atom divided by
-    
-    the total positive charge.
-    
-    -->Rpc
-    
-    Usage:
-    
-        result=CalculateRelativePCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        if sum(cc[cc>0])==0:
-            return 0
-        else:
-            return round(max(res)/sum(cc[cc>0]),3)
-
-def CalculateRelativeNCharge(mol):
-    """
-    #################################################################
-    The partial charge of the most negative atom divided
-    
-    by the total negative charge.
-    
-    -->Rnc
-    
-    Usage:
-    
-        result=CalculateRelativeNCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-    Hmol=Chem.AddHs(mol)
-    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
-    res=[]
-    for atom in Hmol.GetAtoms():
-            res.append(float(atom.GetProp('_GasteigerCharge')))
-            
-    if res==[]:
-        return 0
-    else:
-        cc=numpy.array(res,'d')
-        if sum(cc[cc<0])==0:
-            return 0
-        else:
-            return round(min(res)/sum(cc[cc<0]),3)
-
-def CalculateLocalDipoleIndex(mol):
-    """
-    #################################################################
-    Calculation of local dipole index (D)
-    
-    -->LDI
-    
-    Usage:
-    
-        result=CalculateLocalDipoleIndex(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-
-    GMCharge.ComputeGasteigerCharges(mol,iter_step)
-    res=[]
-    for atom in mol.GetAtoms():
-        res.append(float(atom.GetProp('_GasteigerCharge')))
-    cc = [numpy.absolute(res[x.GetBeginAtom().GetIdx()]-res[x.GetEndAtom().GetIdx()]) for x in mol.GetBonds()]
-    B=len(mol.GetBonds())
-    
-    return round(sum(cc)/B,3)
-        
-def CalculateSubmolPolarityPara(mol):
-    """
-    #################################################################
-    Calculation of submolecular polarity parameter(SPP)
-    
-    -->SPP
-    
-    Usage:
-    
-        result=CalculateSubmolPolarityPara(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a numeric value.
-    #################################################################
-    """
-
-    return round(CalculateAllMaxPCharge(mol)-CalculateAllMaxNCharge(mol),3)
-
-
-_Charge={'SPP':CalculateSubmolPolarityPara,
-        'LDI':CalculateLocalDipoleIndex,
-        'Rnc':CalculateRelativeNCharge,
-        'Rpc':CalculateRelativePCharge,
-        'Mac':CalculateMeanAbsoulteCharge,
-        'Tac':CalculateTotalAbsoulteCharge,
-        'Mnc':CalculateMeanNCharge,
-        'Tnc':CalculateTotalNCharge,
-        'Mpc':CalculateMeanPCharge,
-        'Tpc':CalculateTotalPCharge,
-        'Qass':CalculateAllSumSquareCharge,
-        'QOss':CalculateOSumSquareCharge,
-        'QNss':CalculateNSumSquareCharge,
-        'QCss':CalculateCSumSquareCharge,
-        'QHss':CalculateHSumSquareCharge,
-        'Qmin':CalculateAllMaxNCharge,
-        'Qmax':CalculateAllMaxPCharge,
-        'QOmin':CalculateOMaxNCharge,
-        'QNmin':CalculateNMaxNCharge,
-        'QCmin':CalculateCMaxNCharge,
-        'QHmin':CalculateHMaxNCharge,
-        'QOmax':CalculateOMaxPCharge,
-        'QNmax':CalculateNMaxPCharge,
-        'QCmax':CalculateCMaxPCharge,
-        'QHmax':CalculateHMaxPCharge,
-    }
-
-
-def GetCharge(mol):
-    """
-    #################################################################
-    Get the dictionary of constitutional descriptors for given moelcule mol
-    
-    Usage:
-    
-        result=GetCharge(mol)
-    
-        Input: mol is a molecule object.
-    
-        Output: result is a dict form containing all charge descriptors.
-    #################################################################
-    """
-    result={}
-    for DesLabel in _Charge.keys():
-        result[DesLabel]=_Charge[DesLabel](mol)
-    return result
-
-##############################################################################
-
-if __name__ =='__main__':
-    
-
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    smi5=['CCCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N']
-    for index, smi in enumerate(smis):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',GetCharge(m)
-        print len(GetCharge(m))
-
-
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+
+The calculation of Charge descriptors based on Gasteiger/Marseli partial 
+
+charges(25). You can freely use and distribute it. If you hava  any problem, 
+
+you could contact with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.09.18
+
+Email: oriental-cds@163.com
+
+##############################################################################
+"""
+from rdkit import Chem
+from rdkit.Chem import rdPartialCharges as GMCharge
+
+import numpy
+
+Version=1.0
+##############################################################################
+iter_step=12
+
+def _CalculateElementMaxPCharge(mol,AtomicNum=6):
+    """
+    #################################################################
+    **Internal used only**
+    
+    Most positive charge on atom with atomic number equal to n
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+        if atom.GetAtomicNum()==AtomicNum:
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        return round(max(res),3)
+
+def _CalculateElementMaxNCharge(mol,AtomicNum=6):
+    """
+    #################################################################
+    **Internal used only**
+    
+    Most negative charge on atom with atomic number equal to n
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+        if atom.GetAtomicNum()==AtomicNum:
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+    if res==[]:
+        return 0
+    else:
+        return round(min(res),3)
+
+
+def CalculateHMaxPCharge(mol):
+    """
+    #################################################################
+    Most positive charge on H atoms
+    
+    -->QHmax
+    
+    Usage:
+    
+        result=CalculateHMaxPCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxPCharge(mol,AtomicNum=1)
+
+
+def CalculateCMaxPCharge(mol):
+    """
+    #################################################################
+    Most positive charge on C atoms
+    
+    -->QCmax
+
+    Usage:
+    
+        result=CalculateCMaxPCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxPCharge(mol,AtomicNum=6)
+
+
+def CalculateNMaxPCharge(mol):
+    """
+    #################################################################
+    Most positive charge on N atoms
+    
+    -->QNmax
+
+    Usage:
+    
+        result=CalculateNMaxPCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxPCharge(mol,AtomicNum=7)
+
+
+def CalculateOMaxPCharge(mol):
+    """
+    #################################################################
+    Most positive charge on O atoms
+    
+    -->QOmax
+
+    Usage:
+    
+        result=CalculateOMaxPCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxPCharge(mol,AtomicNum=8)
+
+def CalculateHMaxNCharge(mol):
+    """
+    #################################################################
+    Most negative charge on H atoms
+  
+    -->QHmin
+
+    Usage:
+    
+        result=CalculateHMaxNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxNCharge(mol,AtomicNum=1)
+
+
+def CalculateCMaxNCharge(mol):
+    """
+    #################################################################
+    Most negative charge on C atoms
+    
+    -->QCmin
+
+    Usage:
+    
+        result=CalculateCMaxNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxNCharge(mol,AtomicNum=6)
+
+
+def CalculateNMaxNCharge(mol):
+    """
+    #################################################################
+    Most negative charge on N atoms
+    
+    -->QNmin
+
+    Usage:
+    
+        result=CalculateNMaxNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxNCharge(mol,AtomicNum=7)
+
+
+def CalculateOMaxNCharge(mol):
+    """
+    #################################################################
+    Most negative charge on O atoms
+    
+    -->QOmin
+
+    Usage:
+    
+        result=CalculateOMaxNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementMaxNCharge(mol,AtomicNum=8)
+
+def CalculateAllMaxPCharge(mol):
+    """
+    #################################################################
+    Most positive charge on ALL atoms
+    
+    -->Qmax
+
+    Usage:
+    
+        result=CalculateAllMaxPCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+    if res==[]:
+        return 0
+    else:
+        return round(max(res),3)
+
+
+def CalculateAllMaxNCharge(mol):
+    """
+    #################################################################
+    Most negative charge on all atoms
+    
+    -->Qmin
+
+    Usage:
+    
+        result=CalculateAllMaxNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+    if res==[]:
+        return 0
+    else:
+        return round(min(res),3)
+
+
+def _CalculateElementSumSquareCharge(mol,AtomicNum=6):
+    """
+    #################################################################
+    **Internal used only**
+    
+    Ths sum of square Charges on all atoms with atomicnumber equal to n
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+        if atom.GetAtomicNum()==AtomicNum:
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+    if res==[]:
+        return 0
+    else:
+        return round(sum(numpy.square(res)),3)
+
+
+def CalculateHSumSquareCharge(mol):
+    
+    """
+    #################################################################
+    The sum of square charges on all H atoms
+    
+    -->QHss
+
+    Usage:
+    
+        result=CalculateHSumSquareCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementSumSquareCharge(mol,AtomicNum=1)
+
+
+def CalculateCSumSquareCharge(mol):
+    """
+    #################################################################
+    The sum of square charges on all C atoms
+    
+    -->QCss
+
+    Usage:
+    
+        result=CalculateCSumSquareCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementSumSquareCharge(mol,AtomicNum=6)
+
+
+def CalculateNSumSquareCharge(mol):
+    """
+    #################################################################
+    The sum of square charges on all N atoms
+    
+    -->QNss
+
+    Usage:
+    
+        result=CalculateNSumSquareCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementSumSquareCharge(mol,AtomicNum=7)
+
+def CalculateOSumSquareCharge(mol):
+    """
+    #################################################################
+    The sum of square charges on all O atoms
+    
+    -->QOss
+
+    Usage:
+    
+        result=CalculateOSumSquareCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementSumSquareCharge(mol,AtomicNum=8)
+
+def CalculateAllSumSquareCharge(mol):
+    """
+    #################################################################
+    The sum of square charges on all atoms
+    
+    -->Qass
+
+    Usage:
+    
+        result=CalculateAllSumSquareCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        return round(sum(numpy.square(res)),3)
+
+def CalculateTotalPCharge(mol):
+    """
+    #################################################################
+    The total postive charge
+    
+    -->Tpc
+
+    Usage:
+    
+        result=CalculateTotalPCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        return round(sum(cc[cc>0]),3)
+
+def CalculateMeanPCharge(mol):
+    """
+    #################################################################
+    The average postive charge
+    
+    -->Mpc
+    
+    Usage:
+    
+        result=CalculateMeanPCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        return round(numpy.mean(cc[cc>0]),3)
+
+
+def CalculateTotalNCharge(mol):
+    """
+    #################################################################
+    The total negative charge
+    
+    -->Tnc
+    
+    Usage:
+    
+        result=CalculateTotalNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        return round(sum(cc[cc<0]),3)
+
+
+def CalculateMeanNCharge(mol):
+    """
+    #################################################################
+    The average negative charge
+    
+    -->Mnc
+    
+    Usage:
+    
+        result=CalculateMeanNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        return round(numpy.mean(cc[cc<0]),3)
+
+
+def CalculateTotalAbsoulteCharge(mol):
+    """
+    #################################################################
+    The total absolute charge
+    
+    -->Tac
+    
+    Usage:
+    
+        result=CalculateTotalAbsoulteCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        return round(sum(numpy.absolute(cc)),3)
+
+def CalculateMeanAbsoulteCharge(mol):
+    """
+    #################################################################
+    The average absolute charge
+    
+    -->Mac
+    
+    Usage:
+    
+        result=CalculateMeanAbsoulteCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        return round(numpy.mean(numpy.absolute(cc)),3)
+
+def CalculateRelativePCharge(mol):
+    """
+    #################################################################
+    The partial charge of the most positive atom divided by
+    
+    the total positive charge.
+    
+    -->Rpc
+    
+    Usage:
+    
+        result=CalculateRelativePCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        if sum(cc[cc>0])==0:
+            return 0
+        else:
+            return round(max(res)/sum(cc[cc>0]),3)
+
+def CalculateRelativeNCharge(mol):
+    """
+    #################################################################
+    The partial charge of the most negative atom divided
+    
+    by the total negative charge.
+    
+    -->Rnc
+    
+    Usage:
+    
+        result=CalculateRelativeNCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+    Hmol=Chem.AddHs(mol)
+    GMCharge.ComputeGasteigerCharges(Hmol,iter_step)
+    res=[]
+    for atom in Hmol.GetAtoms():
+            res.append(float(atom.GetProp('_GasteigerCharge')))
+            
+    if res==[]:
+        return 0
+    else:
+        cc=numpy.array(res,'d')
+        if sum(cc[cc<0])==0:
+            return 0
+        else:
+            return round(min(res)/sum(cc[cc<0]),3)
+
+def CalculateLocalDipoleIndex(mol):
+    """
+    #################################################################
+    Calculation of local dipole index (D)
+    
+    -->LDI
+    
+    Usage:
+    
+        result=CalculateLocalDipoleIndex(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+
+    GMCharge.ComputeGasteigerCharges(mol,iter_step)
+    res=[]
+    for atom in mol.GetAtoms():
+        res.append(float(atom.GetProp('_GasteigerCharge')))
+    cc = [numpy.absolute(res[x.GetBeginAtom().GetIdx()]-res[x.GetEndAtom().GetIdx()]) for x in mol.GetBonds()]
+    B=len(mol.GetBonds())
+    
+    return round(sum(cc)/B,3)
+        
+def CalculateSubmolPolarityPara(mol):
+    """
+    #################################################################
+    Calculation of submolecular polarity parameter(SPP)
+    
+    -->SPP
+    
+    Usage:
+    
+        result=CalculateSubmolPolarityPara(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a numeric value.
+    #################################################################
+    """
+
+    return round(CalculateAllMaxPCharge(mol)-CalculateAllMaxNCharge(mol),3)
+
+
+_Charge={'SPP':CalculateSubmolPolarityPara,
+        'LDI':CalculateLocalDipoleIndex,
+        'Rnc':CalculateRelativeNCharge,
+        'Rpc':CalculateRelativePCharge,
+        'Mac':CalculateMeanAbsoulteCharge,
+        'Tac':CalculateTotalAbsoulteCharge,
+        'Mnc':CalculateMeanNCharge,
+        'Tnc':CalculateTotalNCharge,
+        'Mpc':CalculateMeanPCharge,
+        'Tpc':CalculateTotalPCharge,
+        'Qass':CalculateAllSumSquareCharge,
+        'QOss':CalculateOSumSquareCharge,
+        'QNss':CalculateNSumSquareCharge,
+        'QCss':CalculateCSumSquareCharge,
+        'QHss':CalculateHSumSquareCharge,
+        'Qmin':CalculateAllMaxNCharge,
+        'Qmax':CalculateAllMaxPCharge,
+        'QOmin':CalculateOMaxNCharge,
+        'QNmin':CalculateNMaxNCharge,
+        'QCmin':CalculateCMaxNCharge,
+        'QHmin':CalculateHMaxNCharge,
+        'QOmax':CalculateOMaxPCharge,
+        'QNmax':CalculateNMaxPCharge,
+        'QCmax':CalculateCMaxPCharge,
+        'QHmax':CalculateHMaxPCharge,
+    }
+
+
+def GetCharge(mol):
+    """
+    #################################################################
+    Get the dictionary of constitutional descriptors for given moelcule mol
+    
+    Usage:
+    
+        result=GetCharge(mol)
+    
+        Input: mol is a molecule object.
+    
+        Output: result is a dict form containing all charge descriptors.
+    #################################################################
+    """
+    result={}
+    for DesLabel in _Charge.keys():
+        result[DesLabel]=_Charge[DesLabel](mol)
+    return result
+
+##############################################################################
+
+if __name__ =='__main__':
+    
+
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    smi5=['CCCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N']
+    for index, smi in enumerate(smis):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+        print('\t',GetCharge(m))
+        print(len(GetCharge(m)))
+
+
diff -Naur pychem-1.0/src/pychem/connectivity.py pychem-1.0.3/src/pychem/connectivity.py
--- pychem-1.0/src/pychem/connectivity.py	2012-09-19 06:04:15.000000000 -0700
+++ pychem-1.0.3/src/pychem/connectivity.py	2017-01-20 11:03:44.676668232 -0800
@@ -1197,7 +1197,7 @@
 
     for index, smi in enumerate(smis):
         m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',GetConnectivity(m)
-        print '\t',len(GetConnectivity(m))
+        print(index+1)
+        print(smi)      
+        print('\t',GetConnectivity(m))
+        print('\t',len(GetConnectivity(m)))
diff -Naur pychem-1.0/src/pychem/constitution.py pychem-1.0.3/src/pychem/constitution.py
--- pychem-1.0/src/pychem/constitution.py	2012-11-14 05:37:33.000000000 -0800
+++ pychem-1.0.3/src/pychem/constitution.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,718 +1,718 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-The calculation of molecular constitutional indices based on its topological
-
-structure. You can get 30 molecular connectivity descriptors. You can freely
-
-use and distribute it. If you hava  any problem, you could contact with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.09.18
-
-Email: oriental-cds@163.com
-##############################################################################
-"""
-
-from rdkit import Chem
-#from rdkit.Chem import rdchem
-from rdkit.Chem import Lipinski as LPK
-
-#import math
-
-Version=1.0
-#############################################################
-
-def CalculateMolWeight(mol):
-    
-    """
-    #################################################################
-    Calculation of molecular weight
-    
-    Note that not including H
-    
-    ---->Weight  
-    
-    Usage:
-        
-        result=CalculateMolWeight(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-        
-    #################################################################
-    """
-    MolWeight=0
-    for atom in mol.GetAtoms():
-        MolWeight=MolWeight+atom.GetMass()
-
-    return MolWeight
-
-
-def CalculateAverageMolWeight(mol):
-    """
-    #################################################################
-    Calcualtion of average molecular weight
-    
-    Note that not including H
-    
-    ---->AWeight
-    
-    Usage:
-        
-        result=CalculateAverageMolWeight(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    
-    MolWeight=0
-    for atom in mol.GetAtoms():
-        MolWeight=MolWeight+atom.GetMass()
-
-    return MolWeight/mol.GetNumAtoms()
-
-
-def CalculateHydrogenNumber(mol):
-
-    """
-    #################################################################
-    Calculation of Number of Hydrogen in a molecule
-    
-    ---->nhyd
-    
-    Usage:
-        
-        result=CalculateHydrogenNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    i=0
-    Hmol=Chem.AddHs(mol)
-    for atom in Hmol.GetAtoms():
-        if atom.GetAtomicNum()==1:
-            i=i+1
-            
-    return i
-
-def CalculateHalogenNumber(mol):
-
-    """
-    #################################################################
-    Calculation of Halogen counts in a molecule
-    
-    ---->nhal
-    
-    Usage:
-        
-        result=CalculateHalogenNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    i=0
-    for atom in mol.GetAtoms():
-        if atom.GetAtomicNum()==9 or atom.GetAtomicNum()==17 or atom.GetAtomicNum()==35 or atom.GetAtomicNum()==53:
-            i=i+1
-    return i
-            
-
-
-def CalculateHeteroNumber(mol):
-    """
-    #################################################################
-    Calculation of Hetero counts in a molecule
-    
-    ---->nhet
-    
-    Usage:
-        
-        result=CalculateHeteroNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    i=0
-    for atom in mol.GetAtoms():
-        if atom.GetAtomicNum()==6 or atom.GetAtomicNum()==1:
-            i=i+1
-
-    return mol.GetNumAtoms()-i
-
-
-
-def CalculateHeavyAtomNumber(mol):
-    """
-    #################################################################
-    Calculation of Heavy atom counts in a molecule
-    
-    ---->nhev
-    
-    Usage:
-        
-        result=CalculateHeavyAtomNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return mol.GetNumAtoms(onlyHeavy=1)
-
-
-def _CalculateElementNumber(mol,AtomicNumber=6):
-
-    """
-    #################################################################
-    **Internal used only**
-    
-    Calculation of element counts with atomic number equal to n in a molecule
-    #################################################################
-    """
-    i=0
-    for atom in mol.GetAtoms():
-        if atom.GetAtomicNum()==AtomicNumber:
-            i=i+1
-            
-    return i
-
-
-def CalculateFluorinNumber(mol):
-
-    """
-    #################################################################
-    Calculation of Fluorin counts in a molecule
-    
-    ---->ncof
-    
-    Usage:
-        
-        result=CalculateFluorinNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-            
-    return _CalculateElementNumber(mol,AtomicNumber=9)
-
-
-def CalculateChlorinNumber(mol):
-
-    """
-    #################################################################
-    Calculation of Chlorin counts in a molecule
-    
-    ---->ncocl
-    
-    Usage:
-        
-        result=CalculateChlorinNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-
-    return _CalculateElementNumber(mol,AtomicNumber=17)
-
-
-def CalculateBromineNumber(mol):
-
-    """
-    #################################################################
-    Calculation of Bromine counts in a molecule
-    
-    ---->ncobr
-    
-    Usage:
-        
-        result=CalculateBromineNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-
-    return _CalculateElementNumber(mol,AtomicNumber=35)
-
-def CalculateIodineNumber(mol):
-    """
-    #################################################################
-    Calculation of Iodine counts in a molecule
-    
-    ---->ncoi
-    
-    Usage:
-        
-        result=CalculateIodineNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-
-    return _CalculateElementNumber(mol,AtomicNumber=53)
-
-
-def CalculateCarbonNumber(mol):
-
-    """
-    #################################################################
-    Calculation of Carbon number in a molecule
-    
-    ---->ncarb
-    
-    Usage:
-        
-        result=CalculateCarbonNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-
-    return _CalculateElementNumber(mol,AtomicNumber=6)
-
-def CalculatePhosphorNumber(mol):
-    """
-    #################################################################
-    Calcualtion of Phosphor number in a molecule
-    
-    ---->nphos
-    
-    Usage:
-        
-        result=CalculatePhosphorNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementNumber(mol,AtomicNumber=15)
-
-
-def CalculateSulfurNumber(mol):
-    """
-    #################################################################
-    Calculation of Sulfur counts in a molecule
-    
-    ---->nsulph
-    
-    Usage:
-        
-        result=CalculateSulfurNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return _CalculateElementNumber(mol,AtomicNumber=16)
-
-
-
-def CalculateOxygenNumber(mol):
-    """
-    #################################################################
-    Calculation of Oxygen counts in a molecule
-    
-    ---->noxy
-    
-    Usage:
-        
-        result=CalculateOxygenNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-
-    """
-    return _CalculateElementNumber(mol,AtomicNumber=8)
-        
-
-
-def CalculateNitrogenNumber(mol):
-    """
-    #################################################################
-    Calculation of Nitrogen counts in a molecule
-    
-    ---->nnitro
-    
-    Usage:
-        
-        result=CalculateNitrogenNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    
-    return _CalculateElementNumber(mol,AtomicNumber=7)
-
-
-def CalculateRingNumber(mol):
-    """
-    #################################################################
-    Calculation of ring counts in a molecule
-    
-    ---->nring
-    
-    Usage:
-        
-        result=CalculateRingNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return Chem.GetSSSR(mol)
-
-
-def CalculateRotationBondNumber(mol):
-    """
-    #################################################################
-    Calculation of rotation bonds counts in a molecule
-    
-    ---->nrot
-    
-    Note that this is the same as calculation of single bond
-    
-    counts in a molecule.
-    
-    Usage:
-        
-        result=CalculateRotationBondNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return LPK.NumRotatableBonds(mol)
-
-
-def CalculateHdonorNumber(mol):
-    """
-    #################################################################
-    Calculation of Hydrongen bond donor counts in a molecule
-    
-    ---->ndonr
-    
-    Usage:
-        
-        result=CalculateHdonorNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return LPK.NumHDonors(mol)
-
-
-
-def CalculateHacceptorNumber(mol):
-    """
-    #################################################################
-    Calculation of Hydrogen bond acceptor counts in a molecule
-    
-    ---->naccr
-    
-    Usage:
-        
-        result=CalculateHacceptorNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return LPK.NumHAcceptors(mol)
-
-
-def CalculateSingleBondNumber(mol):
-
-    """
-    #################################################################
-    Calculation of single bond counts in a molecule
-    
-    ---->nsb
-    
-    Usage:
-        
-        result=CalculateSingleBondNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    i=0;
-    for bond in mol.GetBonds():
-
-        if bond.GetBondType().name=='SINGLE':
-            i=i+1
-            
-    return i
-            
-
-def CalculateDoubleBondNumber(mol):
-
-    """
-    #################################################################
-    Calculation of double bond counts in a molecule
-    
-    ---->ndb
-    
-    Usage:
-        
-        result=CalculateDoubleBondNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    i=0;
-    for bond in mol.GetBonds():
-
-        if bond.GetBondType().name=='DOUBLE':
-            i=i+1
-            
-    return i
-            
-        
-
-def CalculateTripleBondNumber(mol):
-
-    """
-    #################################################################
-    Calculation of triple bond counts in a molecule
-    
-    ---->ntb
-    
-    Usage:
-        
-        result=CalculateTripleBondNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    i=0;
-    for bond in mol.GetBonds():
-
-        if bond.GetBondType().name=='TRIPLE':
-            i=i+1
-            
-    return i
-            
-def CalculateAromaticBondNumber(mol):
-
-    """
-    #################################################################
-    Calculation of aromatic bond counts in a molecule
-    
-    ---->naro
-    
-    Usage:
-        
-        result=CalculateAromaticBondNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    i=0;
-    for bond in mol.GetBonds():
-
-        if bond.GetBondType().name=='AROMATIC':
-            i=i+1
-            
-    return i
-    
-def CalculateAllAtomNumber(mol):
-    """
-    #################################################################
-    Calculation of all atom counts in a molecule
-    
-    ---->nta
-    
-    Usage:
-        
-        result=CalculateAllAtomNumber(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    
-    return Chem.AddHs(mol).GetNumAtoms()
-        
-def _CalculatePathN(mol,PathLength=2):
-    """
-    #################################################################
-    *Internal Use Only*
-    
-    Calculation of the counts of path length N for a molecule
-    
-    ---->PC1-PC6
-    
-    Usage:
-        
-        result=CalculateMolWeight(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return len(Chem.FindAllPathsOfLengthN(mol,PathLength,useBonds=1))
-
-def CalculatePath1(mol):
-    """
-    #################################################################
-    Calculation of the counts of path length 1 for a molecule
-    #################################################################
-    """
-    return _CalculatePathN(mol,1)
-
-def CalculatePath2(mol):
-    """
-    #################################################################
-    Calculation of the counts of path length 2 for a molecule
-    #################################################################
-    """
-    return _CalculatePathN(mol,2)
-
-def CalculatePath3(mol):
-    """
-    #################################################################
-    Calculation of the counts of path length 3 for a molecule
-    #################################################################
-    """
-    return _CalculatePathN(mol,3)
-
-def CalculatePath4(mol):
-    """
-    #################################################################
-    Calculation of the counts of path length 4 for a molecule
-    #################################################################
-    """
-    return _CalculatePathN(mol,4)
-
-def CalculatePath5(mol):
-    """
-    #################################################################
-    Calculation of the counts of path length 5 for a molecule
-    #################################################################
-    """
-    return _CalculatePathN(mol,5)
-
-def CalculatePath6(mol):
-    """
-    #################################################################
-    Calculation of the counts of path length 6 for a molecule
-    #################################################################
-    """
-    return _CalculatePathN(mol,6)
-
-
-_constitutional={'Weight':CalculateMolWeight,
-                'AWeight':CalculateAverageMolWeight,
-                'nhyd':CalculateHydrogenNumber,
-                'nhal':CalculateHalogenNumber,
-                'nhet':CalculateHeteroNumber,
-                'nhev':CalculateHeavyAtomNumber,
-                'ncof':CalculateFluorinNumber,
-                'ncocl':CalculateChlorinNumber,
-                'ncobr':CalculateBromineNumber,
-                'ncoi':CalculateIodineNumber,
-                'ncarb':CalculateCarbonNumber,
-                'nphos':CalculatePhosphorNumber,
-                'nsulph':CalculateOxygenNumber,
-                'noxy':CalculateOxygenNumber,
-                'nnitro':CalculateNitrogenNumber,
-                'nring':CalculateRingNumber,
-                'nrot':CalculateRotationBondNumber,
-                'ndonr':CalculateHdonorNumber,
-                'naccr':CalculateHacceptorNumber,
-                'nsb':CalculateSingleBondNumber,
-                'ndb':CalculateDoubleBondNumber,
-                'naro':CalculateAromaticBondNumber,
-                'ntb':CalculateTripleBondNumber,
-                'nta':CalculateAllAtomNumber,
-                'PC1':CalculatePath1,
-                'PC2':CalculatePath2,
-                'PC3':CalculatePath3,
-                'PC4':CalculatePath4,
-                'PC5':CalculatePath5,
-                'PC6':CalculatePath6
-    }
-
-def GetConstitutional(mol):
-    """
-    #################################################################
-    Get the dictionary of constitutional descriptors for given moelcule mol
-    
-    Usage:
-        
-        result=GetConstitutional(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a dict form containing all constitutional values.
-    #################################################################
-    """
-    result={}
-    for DesLabel in _constitutional.keys():
-        result[DesLabel]=round(_constitutional[DesLabel](mol),3)
-    return result
-
-
-def _GetHTMLDoc():
-    """
-    #################################################################
-    Write HTML documentation for this module.
-    #################################################################
-    """
-    import pydoc
-    pydoc.writedoc('constitution')  
-#############################################################
-
-if __name__ =='__main__':
-    
-
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    smi5=['CCCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N']
-    for index, smi in enumerate(smis):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',GetConstitutional(m)
-        print len(GetConstitutional(m))
-    
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+The calculation of molecular constitutional indices based on its topological
+
+structure. You can get 30 molecular connectivity descriptors. You can freely
+
+use and distribute it. If you hava  any problem, you could contact with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.09.18
+
+Email: oriental-cds@163.com
+##############################################################################
+"""
+
+from rdkit import Chem
+#from rdkit.Chem import rdchem
+from rdkit.Chem import Lipinski as LPK
+
+#import math
+
+Version=1.0
+#############################################################
+
+def CalculateMolWeight(mol):
+    
+    """
+    #################################################################
+    Calculation of molecular weight
+    
+    Note that not including H
+    
+    ---->Weight  
+    
+    Usage:
+        
+        result=CalculateMolWeight(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+        
+    #################################################################
+    """
+    MolWeight=0
+    for atom in mol.GetAtoms():
+        MolWeight=MolWeight+atom.GetMass()
+
+    return MolWeight
+
+
+def CalculateAverageMolWeight(mol):
+    """
+    #################################################################
+    Calcualtion of average molecular weight
+    
+    Note that not including H
+    
+    ---->AWeight
+    
+    Usage:
+        
+        result=CalculateAverageMolWeight(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    
+    MolWeight=0
+    for atom in mol.GetAtoms():
+        MolWeight=MolWeight+atom.GetMass()
+
+    return MolWeight/mol.GetNumAtoms()
+
+
+def CalculateHydrogenNumber(mol):
+
+    """
+    #################################################################
+    Calculation of Number of Hydrogen in a molecule
+    
+    ---->nhyd
+    
+    Usage:
+        
+        result=CalculateHydrogenNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    i=0
+    Hmol=Chem.AddHs(mol)
+    for atom in Hmol.GetAtoms():
+        if atom.GetAtomicNum()==1:
+            i=i+1
+            
+    return i
+
+def CalculateHalogenNumber(mol):
+
+    """
+    #################################################################
+    Calculation of Halogen counts in a molecule
+    
+    ---->nhal
+    
+    Usage:
+        
+        result=CalculateHalogenNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    i=0
+    for atom in mol.GetAtoms():
+        if atom.GetAtomicNum()==9 or atom.GetAtomicNum()==17 or atom.GetAtomicNum()==35 or atom.GetAtomicNum()==53:
+            i=i+1
+    return i
+            
+
+
+def CalculateHeteroNumber(mol):
+    """
+    #################################################################
+    Calculation of Hetero counts in a molecule
+    
+    ---->nhet
+    
+    Usage:
+        
+        result=CalculateHeteroNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    i=0
+    for atom in mol.GetAtoms():
+        if atom.GetAtomicNum()==6 or atom.GetAtomicNum()==1:
+            i=i+1
+
+    return mol.GetNumAtoms()-i
+
+
+
+def CalculateHeavyAtomNumber(mol):
+    """
+    #################################################################
+    Calculation of Heavy atom counts in a molecule
+    
+    ---->nhev
+    
+    Usage:
+        
+        result=CalculateHeavyAtomNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return mol.GetNumAtoms(onlyHeavy=1)
+
+
+def _CalculateElementNumber(mol,AtomicNumber=6):
+
+    """
+    #################################################################
+    **Internal used only**
+    
+    Calculation of element counts with atomic number equal to n in a molecule
+    #################################################################
+    """
+    i=0
+    for atom in mol.GetAtoms():
+        if atom.GetAtomicNum()==AtomicNumber:
+            i=i+1
+            
+    return i
+
+
+def CalculateFluorinNumber(mol):
+
+    """
+    #################################################################
+    Calculation of Fluorin counts in a molecule
+    
+    ---->ncof
+    
+    Usage:
+        
+        result=CalculateFluorinNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+            
+    return _CalculateElementNumber(mol,AtomicNumber=9)
+
+
+def CalculateChlorinNumber(mol):
+
+    """
+    #################################################################
+    Calculation of Chlorin counts in a molecule
+    
+    ---->ncocl
+    
+    Usage:
+        
+        result=CalculateChlorinNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+
+    return _CalculateElementNumber(mol,AtomicNumber=17)
+
+
+def CalculateBromineNumber(mol):
+
+    """
+    #################################################################
+    Calculation of Bromine counts in a molecule
+    
+    ---->ncobr
+    
+    Usage:
+        
+        result=CalculateBromineNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+
+    return _CalculateElementNumber(mol,AtomicNumber=35)
+
+def CalculateIodineNumber(mol):
+    """
+    #################################################################
+    Calculation of Iodine counts in a molecule
+    
+    ---->ncoi
+    
+    Usage:
+        
+        result=CalculateIodineNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+
+    return _CalculateElementNumber(mol,AtomicNumber=53)
+
+
+def CalculateCarbonNumber(mol):
+
+    """
+    #################################################################
+    Calculation of Carbon number in a molecule
+    
+    ---->ncarb
+    
+    Usage:
+        
+        result=CalculateCarbonNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+
+    return _CalculateElementNumber(mol,AtomicNumber=6)
+
+def CalculatePhosphorNumber(mol):
+    """
+    #################################################################
+    Calcualtion of Phosphor number in a molecule
+    
+    ---->nphos
+    
+    Usage:
+        
+        result=CalculatePhosphorNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementNumber(mol,AtomicNumber=15)
+
+
+def CalculateSulfurNumber(mol):
+    """
+    #################################################################
+    Calculation of Sulfur counts in a molecule
+    
+    ---->nsulph
+    
+    Usage:
+        
+        result=CalculateSulfurNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return _CalculateElementNumber(mol,AtomicNumber=16)
+
+
+
+def CalculateOxygenNumber(mol):
+    """
+    #################################################################
+    Calculation of Oxygen counts in a molecule
+    
+    ---->noxy
+    
+    Usage:
+        
+        result=CalculateOxygenNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+
+    """
+    return _CalculateElementNumber(mol,AtomicNumber=8)
+        
+
+
+def CalculateNitrogenNumber(mol):
+    """
+    #################################################################
+    Calculation of Nitrogen counts in a molecule
+    
+    ---->nnitro
+    
+    Usage:
+        
+        result=CalculateNitrogenNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    
+    return _CalculateElementNumber(mol,AtomicNumber=7)
+
+
+def CalculateRingNumber(mol):
+    """
+    #################################################################
+    Calculation of ring counts in a molecule
+    
+    ---->nring
+    
+    Usage:
+        
+        result=CalculateRingNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return Chem.GetSSSR(mol)
+
+
+def CalculateRotationBondNumber(mol):
+    """
+    #################################################################
+    Calculation of rotation bonds counts in a molecule
+    
+    ---->nrot
+    
+    Note that this is the same as calculation of single bond
+    
+    counts in a molecule.
+    
+    Usage:
+        
+        result=CalculateRotationBondNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return LPK.NumRotatableBonds(mol)
+
+
+def CalculateHdonorNumber(mol):
+    """
+    #################################################################
+    Calculation of Hydrongen bond donor counts in a molecule
+    
+    ---->ndonr
+    
+    Usage:
+        
+        result=CalculateHdonorNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return LPK.NumHDonors(mol)
+
+
+
+def CalculateHacceptorNumber(mol):
+    """
+    #################################################################
+    Calculation of Hydrogen bond acceptor counts in a molecule
+    
+    ---->naccr
+    
+    Usage:
+        
+        result=CalculateHacceptorNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return LPK.NumHAcceptors(mol)
+
+
+def CalculateSingleBondNumber(mol):
+
+    """
+    #################################################################
+    Calculation of single bond counts in a molecule
+    
+    ---->nsb
+    
+    Usage:
+        
+        result=CalculateSingleBondNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    i=0;
+    for bond in mol.GetBonds():
+
+        if bond.GetBondType().name=='SINGLE':
+            i=i+1
+            
+    return i
+            
+
+def CalculateDoubleBondNumber(mol):
+
+    """
+    #################################################################
+    Calculation of double bond counts in a molecule
+    
+    ---->ndb
+    
+    Usage:
+        
+        result=CalculateDoubleBondNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    i=0;
+    for bond in mol.GetBonds():
+
+        if bond.GetBondType().name=='DOUBLE':
+            i=i+1
+            
+    return i
+            
+        
+
+def CalculateTripleBondNumber(mol):
+
+    """
+    #################################################################
+    Calculation of triple bond counts in a molecule
+    
+    ---->ntb
+    
+    Usage:
+        
+        result=CalculateTripleBondNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    i=0;
+    for bond in mol.GetBonds():
+
+        if bond.GetBondType().name=='TRIPLE':
+            i=i+1
+            
+    return i
+            
+def CalculateAromaticBondNumber(mol):
+
+    """
+    #################################################################
+    Calculation of aromatic bond counts in a molecule
+    
+    ---->naro
+    
+    Usage:
+        
+        result=CalculateAromaticBondNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    i=0;
+    for bond in mol.GetBonds():
+
+        if bond.GetBondType().name=='AROMATIC':
+            i=i+1
+            
+    return i
+    
+def CalculateAllAtomNumber(mol):
+    """
+    #################################################################
+    Calculation of all atom counts in a molecule
+    
+    ---->nta
+    
+    Usage:
+        
+        result=CalculateAllAtomNumber(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    
+    return Chem.AddHs(mol).GetNumAtoms()
+        
+def _CalculatePathN(mol,PathLength=2):
+    """
+    #################################################################
+    *Internal Use Only*
+    
+    Calculation of the counts of path length N for a molecule
+    
+    ---->PC1-PC6
+    
+    Usage:
+        
+        result=CalculateMolWeight(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return len(Chem.FindAllPathsOfLengthN(mol,PathLength,useBonds=1))
+
+def CalculatePath1(mol):
+    """
+    #################################################################
+    Calculation of the counts of path length 1 for a molecule
+    #################################################################
+    """
+    return _CalculatePathN(mol,1)
+
+def CalculatePath2(mol):
+    """
+    #################################################################
+    Calculation of the counts of path length 2 for a molecule
+    #################################################################
+    """
+    return _CalculatePathN(mol,2)
+
+def CalculatePath3(mol):
+    """
+    #################################################################
+    Calculation of the counts of path length 3 for a molecule
+    #################################################################
+    """
+    return _CalculatePathN(mol,3)
+
+def CalculatePath4(mol):
+    """
+    #################################################################
+    Calculation of the counts of path length 4 for a molecule
+    #################################################################
+    """
+    return _CalculatePathN(mol,4)
+
+def CalculatePath5(mol):
+    """
+    #################################################################
+    Calculation of the counts of path length 5 for a molecule
+    #################################################################
+    """
+    return _CalculatePathN(mol,5)
+
+def CalculatePath6(mol):
+    """
+    #################################################################
+    Calculation of the counts of path length 6 for a molecule
+    #################################################################
+    """
+    return _CalculatePathN(mol,6)
+
+
+_constitutional={'Weight':CalculateMolWeight,
+                'AWeight':CalculateAverageMolWeight,
+                'nhyd':CalculateHydrogenNumber,
+                'nhal':CalculateHalogenNumber,
+                'nhet':CalculateHeteroNumber,
+                'nhev':CalculateHeavyAtomNumber,
+                'ncof':CalculateFluorinNumber,
+                'ncocl':CalculateChlorinNumber,
+                'ncobr':CalculateBromineNumber,
+                'ncoi':CalculateIodineNumber,
+                'ncarb':CalculateCarbonNumber,
+                'nphos':CalculatePhosphorNumber,
+                'nsulph':CalculateOxygenNumber,
+                'noxy':CalculateOxygenNumber,
+                'nnitro':CalculateNitrogenNumber,
+                'nring':CalculateRingNumber,
+                'nrot':CalculateRotationBondNumber,
+                'ndonr':CalculateHdonorNumber,
+                'naccr':CalculateHacceptorNumber,
+                'nsb':CalculateSingleBondNumber,
+                'ndb':CalculateDoubleBondNumber,
+                'naro':CalculateAromaticBondNumber,
+                'ntb':CalculateTripleBondNumber,
+                'nta':CalculateAllAtomNumber,
+                'PC1':CalculatePath1,
+                'PC2':CalculatePath2,
+                'PC3':CalculatePath3,
+                'PC4':CalculatePath4,
+                'PC5':CalculatePath5,
+                'PC6':CalculatePath6
+    }
+
+def GetConstitutional(mol):
+    """
+    #################################################################
+    Get the dictionary of constitutional descriptors for given moelcule mol
+    
+    Usage:
+        
+        result=GetConstitutional(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a dict form containing all constitutional values.
+    #################################################################
+    """
+    result={}
+    for DesLabel in _constitutional.keys():
+        result[DesLabel]=round(_constitutional[DesLabel](mol),3)
+    return result
+
+
+def _GetHTMLDoc():
+    """
+    #################################################################
+    Write HTML documentation for this module.
+    #################################################################
+    """
+    import pydoc
+    pydoc.writedoc('constitution')  
+#############################################################
+
+if __name__ =='__main__':
+    
+
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    smi5=['CCCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N']
+    for index, smi in enumerate(smis):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+        print('\t',GetConstitutional(m))
+        print(len(GetConstitutional(m)))
+    
diff -Naur pychem-1.0/src/pychem/cpsa.py pychem-1.0.3/src/pychem/cpsa.py
--- pychem-1.0/src/pychem/cpsa.py	2012-11-14 08:50:45.000000000 -0800
+++ pychem-1.0.3/src/pychem/cpsa.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,590 +1,590 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-This module is used for calculating charged partial surface area descriptors
-
-(CPSA) proposed by Peter. Jurs. If you have any question please contact me
-
-via email.
-
-Created on Tue Apr 19 10:40:45 2011
-
-@author: Dongsheng Cao, Yizeng Liang, Qingsong Xu
-##############################################################################
-"""
-
-import asa
-import pybel
-from GeoOpt import GetAtomClassList, _ReadCoordinates
-
-
-Version=1.0
-############################################################################
-filename='temp'
-
-def GetChargeSA(RadiusProbe=1.5,n_sphere_point=960):
-    """
-    #################################################################
-    Get the list form for all atoms in a molecule.
-    
-    It includes the atom symbol, charge and partial solvent-accessible 
-    
-    surface areas. 
-    
-    Note that this is list form whose element is still list form of each atom.
-    #################################################################
-    """
-    ChargeCoordinates=_ReadCoordinates(filename)
-    atoms=GetAtomClassList(ChargeCoordinates)
-    FASA=asa.calculate_asa(atoms, RadiusProbe, n_sphere_point)
-    
-    res=[]
-    for i in range(len(FASA)):
-        res.append([ChargeCoordinates[i][0],ChargeCoordinates[i][4],FASA[i]])
-        
-    return res
-        
-
-def CalculateASA(ChargeSA):
-    """
-    #################################################################
-    The calculation of solvent-accessible surface areas
-    
-    -->ASA
-    #################################################################
-    """
-    res=0.0
-    for i in ChargeSA:
-        res=res+i[2]
-    return res
-    
-def CalculateMSA():
-    """
-    #################################################################
-    The calculation of molecular surface areas
-    
-    -->MSA
-    #################################################################
-    """
-    ChargeSA=GetChargeSA(RadiusProbe=0,n_sphere_point=960)
-    res=0.0
-    for i in ChargeSA:
-        res=res+i[2]
-    return res
-    
-    
-def CalculatePNSA1(ChargeSA):
-    """
-    #################################################################
-    The calculation of partial negative area
-    
-    It is the sum of the solvent-accessible surface areas of all 
-    
-    negatively charged atoms.
-    
-    -->PNSA1
-    #################################################################
-    """
-    res=0.0
-    for i in ChargeSA:
-        if float(i[1])<0:
-            res=res+i[2]
-            
-    return res
-            
-
-def CalculatePPSA1(ChargeSA):
-    """
-    #################################################################
-    The calculation of partial negative area
-    
-    It is the sum of the solvent-accessible surface areas of 
-    
-    all positively charged atoms.
-    
-    -->PPSA1
-    #################################################################
-    """
-    res=0.0
-    for i in ChargeSA:
-        if float(i[1])>0:
-            res=res+i[2]
-            
-    return res
-
-def CalculatePNSA2(ChargeSA):
-    """
-    #################################################################
-    The calculation of total charge wighted negative surface area
-    
-    It is the partial negative solvent-accessible surface area 
-    
-    multiplied by the total negative charge.
-    
-    -->PNSA2
-    #################################################################
-    """
-    temp1=temp2=0.0
-    for i in ChargeSA:
-        if float(i[1])<0:
-            temp1=temp1+float(i[1])
-            temp2=temp2+i[2]
-    res=temp1*temp2
-    
-    return res
-            
-
-
-def CalculatePPSA2(ChargeSA):
-    """
-    #################################################################
-    The calculation of total charge wighted negative surface area
-    
-    It is the partial negative solvent-accessible surface area 
-    
-    multiplied by the total positive charge.
-    
-    -->PPSA2
-    #################################################################
-    """
-    temp1=temp2=0.0
-    for i in ChargeSA:
-        if float(i[1])>0:
-            temp1=temp1+float(i[1])
-            temp2=temp2+i[2]
-    res=temp1*temp2
-    
-    return res
-
-def CalculatePNSA3(ChargeSA):
-    """
-    #################################################################
-    The calculation of atom charge weighted negative surface ares
-    
-    It is the sum of the products of atomic solvent-accessible 
-    
-    surface area and partial charges over all negatively charges atoms.
-    
-    -->PNSA3
-    #################################################################
-    """
-    res=0.0
-    for i in ChargeSA:
-        if float(i[1])<0:
-            res=res+float(i[1])*i[2]
-    return res
-
-
-def CalculatePPSA3(ChargeSA):
-    """
-    #################################################################
-    The calculation of atom charge weighted positive surface ares
-    
-    It is the sum of the products of atomic solvent-accessible
-    
-    surface area and partial charges over all positively charges atoms.
-    
-    -->PPSA3
-    #################################################################
-    """
-    res=0.0
-    for i in ChargeSA:
-        if float(i[1])>0:
-            res=res+float(i[1])*i[2]
-    return res
-
-
-def CalculateDPSA1(ChargeSA):
-    """
-    #################################################################
-    The calculation of difference in charged partial surface area
-    -->DPSA1
-    #################################################################
-    """
-    return CalculatePPSA1(ChargeSA)-CalculatePNSA1(ChargeSA)
-
-
-def CalculateDPSA2(ChargeSA):
-    """
-    #################################################################
-    The calculation of difference in total charge weighted partial
-    
-    surface area
-    
-    -->DPSA2
-    #################################################################
-    """
-    return CalculatePPSA2(ChargeSA)-CalculatePNSA2(ChargeSA)
-
-def CalculateDPSA3(ChargeSA):
-    """
-    #################################################################
-    The calculation of difference in atomic charge weighted surface area
-    
-    -->DPSA3
-    #################################################################
-    """
-    return CalculatePPSA3(ChargeSA)-CalculatePNSA3(ChargeSA)
-
-def CalculateFNSA1(ChargeSA):
-    """
-    #################################################################
-    The calculation of fractional charged partial negative surface areas
-    
-    -->FNSA1
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePNSA1(ChargeSA)/temp
-
-def CalculateFNSA2(ChargeSA):
-    """
-    #################################################################
-    The calculation of fractional charged partial negative surface areas
-    
-    -->FNSA2
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePNSA2(ChargeSA)/temp
-
-
-def CalculateFNSA3(ChargeSA):
-    """
-    #################################################################
-    The calculation of fractional charged partial negative surface areas
-    
-    -->FNSA3
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePNSA3(ChargeSA)/temp
-
-def CalculateFPSA1(ChargeSA):
-    """
-    #################################################################
-    The calculation of fractional charged partial negative surface areas
-    
-    -->FPSA1
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePPSA1(ChargeSA)/temp
-
-def CalculateFPSA2(ChargeSA):
-    """
-    #################################################################
-    The calculation of fractional charged partial negative surface areas
-    
-    -->FPSA2
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePPSA2(ChargeSA)/temp
-
-def CalculateFPSA3(ChargeSA):
-    """
-    #################################################################
-    The calculation of fractional charged partial negative surface
-    
-    areas
-    
-    -->FPSA3
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePPSA3(ChargeSA)/temp
-
-def CalculateWNSA1(ChargeSA):
-    """
-    #################################################################
-    The calculation of surface weighted charged partial negative 
-    
-    surface areas
-    
-    -->WNSA1
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePNSA1(ChargeSA)*temp/1000
-
-def CalculateWNSA2(ChargeSA):
-    """
-    #################################################################
-    The calculation of surface weighted charged partial negative 
-    
-    surface areas
-    
-    -->WNSA2
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePNSA2(ChargeSA)*temp/1000
-
-def CalculateWNSA3(ChargeSA):
-    """
-    #################################################################
-    The calculation of surface weighted charged partial negative 
-    
-    surface areas
-    
-    -->WNSA3
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePNSA3(ChargeSA)*temp/1000
-
-def CalculateWPSA1(ChargeSA):
-    """
-    #################################################################
-    The calculation of surface weighted charged partial negative 
-    
-    surface areas
-    
-    -->WPSA1
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePPSA1(ChargeSA)*temp/1000
-
-def CalculateWPSA2(ChargeSA):
-    """
-    #################################################################
-    The calculation of surface weighted charged partial negative 
-    
-    surface areas
-    
-    -->WPSA2
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePPSA2(ChargeSA)*temp/1000
-
-def CalculateWPSA3(ChargeSA):
-    """
-    #################################################################
-    The calculation of surface weighted charged partial negative
-    
-    surface areas
-    
-    -->WPSA3
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-        
-    return CalculatePPSA3(ChargeSA)*temp/1000
-
-
-def CalculateTASA(ChargeSA):
-    """
-    #################################################################
-    The calculation of total hydrophobic surface area
-    
-    -->TASA
-    #################################################################
-    """
-    res=0.0
-    for i in ChargeSA:
-        if abs(float(i[1]))<0.2:
-            res=res+i[2]
-    return res
-
-def CalculateTPSA(ChargeSA):
-    """
-    #################################################################
-    The calculation of total polar surface area
-    
-    -->PSA
-    #################################################################
-    """
-    res=0.0
-    for i in ChargeSA:
-        if abs(float(i[1]))>=0.2:
-            res=res+i[2]
-    return res
-    
-    
-def CalculateFractionTATP(ChargeSA):
-    """
-    #################################################################
-    The fraction between TASA and TPSA
-    
-    --->FrTATP
-    #################################################################
-    """
-    res=0.0
-    if CalculateTPSA(ChargeSA)==0:
-        return res
-    else:
-        return CalculateTASA(ChargeSA)/CalculateTPSA(ChargeSA)
-
-def CalculateRASA(ChargeSA):
-    """
-    #################################################################
-    The calculation of relative hydrophobic surface area
-    
-    -->RASA
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-    return CalculateTASA(ChargeSA)/temp
-
-def CalculateRPSA(ChargeSA):
-    """
-    #################################################################
-    The calculation of relative polar surface area
-    
-    -->RPSA
-    #################################################################
-    """
-    temp=0.0
-    for i in ChargeSA:
-        temp=temp+i[2]
-    return CalculateTPSA(ChargeSA)/temp
-
-
-def CalculateRNCS(ChargeSA):
-    """
-    #################################################################
-    The calculation of relative negative charge surface area
-    
-    -->RNCS
-    #################################################################
-    """
-    charge=[]
-    for i in ChargeSA:
-        charge.append(float(i[1]))
-    
-    temp=[]
-    for i in ChargeSA:
-        temp.append(i[2])
-     
-    RNCG=min(charge)/sum([i for i in charge if i<0])
-    
-    
-    return  temp[charge.index(min(charge))]/RNCG
-    
-          
-
-def CalculateRPCS(ChargeSA):
-    """
-    #################################################################
-    The calculation of relative positive charge surface area
-    
-    -->RPCS
-    #################################################################
-    """
-    charge=[]
-    for i in ChargeSA:
-        charge.append(float(i[1]))
-    
-    temp=[]
-    for i in ChargeSA:
-        temp.append(i[2])
-     
-    RPCG=max(charge)/sum([i for i in charge if i>0])
-      
-    return  temp[charge.index(min(charge))]/RPCG
-    
-    
-############################################################################
-def GetCPSA():
-    """
-    #################################################################
-    Wrapper for the CPSA descriptors
-    #################################################################
-    """
-    ChargeSA=GetChargeSA(RadiusProbe=1.5,n_sphere_point=5000)
-    
-    res={}
-    res['ASA']=round(CalculateASA(ChargeSA),3)
-    res['MSA']=round(CalculateMSA(),3)
-    res['PNSA1']=round(CalculatePNSA1(ChargeSA),3)
-    res['PNSA2']=round(CalculatePNSA2(ChargeSA),3)
-    res['PNSA3']=round(CalculatePNSA3(ChargeSA),3)
-    res['PPSA1']=round(CalculatePPSA1(ChargeSA),3)
-    res['PPSA2']=round(CalculatePPSA2(ChargeSA),3)
-    res['PPSA3']=round(CalculatePPSA3(ChargeSA),3)
-    res['DPSA1']=round(CalculateDPSA1(ChargeSA),3)
-    res['DPSA2']=round(CalculateDPSA2(ChargeSA),3)
-    res['DPSA3']=round(CalculateDPSA3(ChargeSA),3)
-    res['FNSA1']=round(CalculateFNSA1(ChargeSA),3)
-    res['FNSA2']=round(CalculateFNSA2(ChargeSA),3)
-    res['FNSA3']=round(CalculateFNSA3(ChargeSA),3)
-    res['FPSA1']=round(CalculateFPSA1(ChargeSA),3)
-    res['FPSA2']=round(CalculateFPSA2(ChargeSA),3)
-    res['FPSA3']=round(CalculateFPSA3(ChargeSA),3)
-    res['WNSA1']=round(CalculateWNSA1(ChargeSA),3)
-    res['WNSA2']=round(CalculateWNSA2(ChargeSA),3)
-    res['WNSA3']=round(CalculateWNSA3(ChargeSA),3)
-    res['WPSA1']=round(CalculateWPSA1(ChargeSA),3)
-    res['WPSA2']=round(CalculateWPSA2(ChargeSA),3)
-    res['WPSA3']=round(CalculateWPSA3(ChargeSA),3)
-    res['TASA']=round(CalculateTASA(ChargeSA),3)
-    res['PSA']=round(CalculateTPSA(ChargeSA),3)
-    res['RASA']=round(CalculateRASA(ChargeSA),3)
-    res['RPSA']=round(CalculateRPSA(ChargeSA),3)
-    res['RNCS']=round(CalculateRNCS(ChargeSA),3)
-    res['RPCS']=round(CalculateRPCS(ChargeSA),3)
-    res['FrTATP']=round(CalculateFractionTATP(ChargeSA),3)
-
-
-    return res
-
-
-def _GetHTMLDoc():
-    """
-    #################################################################
-    Write HTML documentation for this module.
-    #################################################################
-    """
-    import pydoc
-    pydoc.writedoc('cpsa')
-#############################################################################    
-if __name__=="__main__":
-    
-    from GeoOpt import GetARCFile
-    mol='C1C=CCS1'
-
-    inputmol=pybel.readstring('smi',mol)  
-    GetARCFile(inputmol)
-    result=GetCPSA()
-    print result
-    print len(result)
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+This module is used for calculating charged partial surface area descriptors
+
+(CPSA) proposed by Peter. Jurs. If you have any question please contact me
+
+via email.
+
+Created on Tue Apr 19 10:40:45 2011
+
+@author: Dongsheng Cao, Yizeng Liang, Qingsong Xu
+##############################################################################
+"""
+
+from . import asa
+import pybel
+from .GeoOpt import GetAtomClassList, _ReadCoordinates
+
+
+Version=1.0
+############################################################################
+filename='temp'
+
+def GetChargeSA(RadiusProbe=1.5,n_sphere_point=960):
+    """
+    #################################################################
+    Get the list form for all atoms in a molecule.
+    
+    It includes the atom symbol, charge and partial solvent-accessible 
+    
+    surface areas. 
+    
+    Note that this is list form whose element is still list form of each atom.
+    #################################################################
+    """
+    ChargeCoordinates=_ReadCoordinates(filename)
+    atoms=GetAtomClassList(ChargeCoordinates)
+    FASA=asa.calculate_asa(atoms, RadiusProbe, n_sphere_point)
+    
+    res=[]
+    for i in range(len(FASA)):
+        res.append([ChargeCoordinates[i][0],ChargeCoordinates[i][4],FASA[i]])
+        
+    return res
+        
+
+def CalculateASA(ChargeSA):
+    """
+    #################################################################
+    The calculation of solvent-accessible surface areas
+    
+    -->ASA
+    #################################################################
+    """
+    res=0.0
+    for i in ChargeSA:
+        res=res+i[2]
+    return res
+    
+def CalculateMSA():
+    """
+    #################################################################
+    The calculation of molecular surface areas
+    
+    -->MSA
+    #################################################################
+    """
+    ChargeSA=GetChargeSA(RadiusProbe=0,n_sphere_point=960)
+    res=0.0
+    for i in ChargeSA:
+        res=res+i[2]
+    return res
+    
+    
+def CalculatePNSA1(ChargeSA):
+    """
+    #################################################################
+    The calculation of partial negative area
+    
+    It is the sum of the solvent-accessible surface areas of all 
+    
+    negatively charged atoms.
+    
+    -->PNSA1
+    #################################################################
+    """
+    res=0.0
+    for i in ChargeSA:
+        if float(i[1])<0:
+            res=res+i[2]
+            
+    return res
+            
+
+def CalculatePPSA1(ChargeSA):
+    """
+    #################################################################
+    The calculation of partial negative area
+    
+    It is the sum of the solvent-accessible surface areas of 
+    
+    all positively charged atoms.
+    
+    -->PPSA1
+    #################################################################
+    """
+    res=0.0
+    for i in ChargeSA:
+        if float(i[1])>0:
+            res=res+i[2]
+            
+    return res
+
+def CalculatePNSA2(ChargeSA):
+    """
+    #################################################################
+    The calculation of total charge wighted negative surface area
+    
+    It is the partial negative solvent-accessible surface area 
+    
+    multiplied by the total negative charge.
+    
+    -->PNSA2
+    #################################################################
+    """
+    temp1=temp2=0.0
+    for i in ChargeSA:
+        if float(i[1])<0:
+            temp1=temp1+float(i[1])
+            temp2=temp2+i[2]
+    res=temp1*temp2
+    
+    return res
+            
+
+
+def CalculatePPSA2(ChargeSA):
+    """
+    #################################################################
+    The calculation of total charge wighted negative surface area
+    
+    It is the partial negative solvent-accessible surface area 
+    
+    multiplied by the total positive charge.
+    
+    -->PPSA2
+    #################################################################
+    """
+    temp1=temp2=0.0
+    for i in ChargeSA:
+        if float(i[1])>0:
+            temp1=temp1+float(i[1])
+            temp2=temp2+i[2]
+    res=temp1*temp2
+    
+    return res
+
+def CalculatePNSA3(ChargeSA):
+    """
+    #################################################################
+    The calculation of atom charge weighted negative surface ares
+    
+    It is the sum of the products of atomic solvent-accessible 
+    
+    surface area and partial charges over all negatively charges atoms.
+    
+    -->PNSA3
+    #################################################################
+    """
+    res=0.0
+    for i in ChargeSA:
+        if float(i[1])<0:
+            res=res+float(i[1])*i[2]
+    return res
+
+
+def CalculatePPSA3(ChargeSA):
+    """
+    #################################################################
+    The calculation of atom charge weighted positive surface ares
+    
+    It is the sum of the products of atomic solvent-accessible
+    
+    surface area and partial charges over all positively charges atoms.
+    
+    -->PPSA3
+    #################################################################
+    """
+    res=0.0
+    for i in ChargeSA:
+        if float(i[1])>0:
+            res=res+float(i[1])*i[2]
+    return res
+
+
+def CalculateDPSA1(ChargeSA):
+    """
+    #################################################################
+    The calculation of difference in charged partial surface area
+    -->DPSA1
+    #################################################################
+    """
+    return CalculatePPSA1(ChargeSA)-CalculatePNSA1(ChargeSA)
+
+
+def CalculateDPSA2(ChargeSA):
+    """
+    #################################################################
+    The calculation of difference in total charge weighted partial
+    
+    surface area
+    
+    -->DPSA2
+    #################################################################
+    """
+    return CalculatePPSA2(ChargeSA)-CalculatePNSA2(ChargeSA)
+
+def CalculateDPSA3(ChargeSA):
+    """
+    #################################################################
+    The calculation of difference in atomic charge weighted surface area
+    
+    -->DPSA3
+    #################################################################
+    """
+    return CalculatePPSA3(ChargeSA)-CalculatePNSA3(ChargeSA)
+
+def CalculateFNSA1(ChargeSA):
+    """
+    #################################################################
+    The calculation of fractional charged partial negative surface areas
+    
+    -->FNSA1
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePNSA1(ChargeSA)/temp
+
+def CalculateFNSA2(ChargeSA):
+    """
+    #################################################################
+    The calculation of fractional charged partial negative surface areas
+    
+    -->FNSA2
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePNSA2(ChargeSA)/temp
+
+
+def CalculateFNSA3(ChargeSA):
+    """
+    #################################################################
+    The calculation of fractional charged partial negative surface areas
+    
+    -->FNSA3
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePNSA3(ChargeSA)/temp
+
+def CalculateFPSA1(ChargeSA):
+    """
+    #################################################################
+    The calculation of fractional charged partial negative surface areas
+    
+    -->FPSA1
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePPSA1(ChargeSA)/temp
+
+def CalculateFPSA2(ChargeSA):
+    """
+    #################################################################
+    The calculation of fractional charged partial negative surface areas
+    
+    -->FPSA2
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePPSA2(ChargeSA)/temp
+
+def CalculateFPSA3(ChargeSA):
+    """
+    #################################################################
+    The calculation of fractional charged partial negative surface
+    
+    areas
+    
+    -->FPSA3
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePPSA3(ChargeSA)/temp
+
+def CalculateWNSA1(ChargeSA):
+    """
+    #################################################################
+    The calculation of surface weighted charged partial negative 
+    
+    surface areas
+    
+    -->WNSA1
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePNSA1(ChargeSA)*temp/1000
+
+def CalculateWNSA2(ChargeSA):
+    """
+    #################################################################
+    The calculation of surface weighted charged partial negative 
+    
+    surface areas
+    
+    -->WNSA2
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePNSA2(ChargeSA)*temp/1000
+
+def CalculateWNSA3(ChargeSA):
+    """
+    #################################################################
+    The calculation of surface weighted charged partial negative 
+    
+    surface areas
+    
+    -->WNSA3
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePNSA3(ChargeSA)*temp/1000
+
+def CalculateWPSA1(ChargeSA):
+    """
+    #################################################################
+    The calculation of surface weighted charged partial negative 
+    
+    surface areas
+    
+    -->WPSA1
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePPSA1(ChargeSA)*temp/1000
+
+def CalculateWPSA2(ChargeSA):
+    """
+    #################################################################
+    The calculation of surface weighted charged partial negative 
+    
+    surface areas
+    
+    -->WPSA2
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePPSA2(ChargeSA)*temp/1000
+
+def CalculateWPSA3(ChargeSA):
+    """
+    #################################################################
+    The calculation of surface weighted charged partial negative
+    
+    surface areas
+    
+    -->WPSA3
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+        
+    return CalculatePPSA3(ChargeSA)*temp/1000
+
+
+def CalculateTASA(ChargeSA):
+    """
+    #################################################################
+    The calculation of total hydrophobic surface area
+    
+    -->TASA
+    #################################################################
+    """
+    res=0.0
+    for i in ChargeSA:
+        if abs(float(i[1]))<0.2:
+            res=res+i[2]
+    return res
+
+def CalculateTPSA(ChargeSA):
+    """
+    #################################################################
+    The calculation of total polar surface area
+    
+    -->PSA
+    #################################################################
+    """
+    res=0.0
+    for i in ChargeSA:
+        if abs(float(i[1]))>=0.2:
+            res=res+i[2]
+    return res
+    
+    
+def CalculateFractionTATP(ChargeSA):
+    """
+    #################################################################
+    The fraction between TASA and TPSA
+    
+    --->FrTATP
+    #################################################################
+    """
+    res=0.0
+    if CalculateTPSA(ChargeSA)==0:
+        return res
+    else:
+        return CalculateTASA(ChargeSA)/CalculateTPSA(ChargeSA)
+
+def CalculateRASA(ChargeSA):
+    """
+    #################################################################
+    The calculation of relative hydrophobic surface area
+    
+    -->RASA
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+    return CalculateTASA(ChargeSA)/temp
+
+def CalculateRPSA(ChargeSA):
+    """
+    #################################################################
+    The calculation of relative polar surface area
+    
+    -->RPSA
+    #################################################################
+    """
+    temp=0.0
+    for i in ChargeSA:
+        temp=temp+i[2]
+    return CalculateTPSA(ChargeSA)/temp
+
+
+def CalculateRNCS(ChargeSA):
+    """
+    #################################################################
+    The calculation of relative negative charge surface area
+    
+    -->RNCS
+    #################################################################
+    """
+    charge=[]
+    for i in ChargeSA:
+        charge.append(float(i[1]))
+    
+    temp=[]
+    for i in ChargeSA:
+        temp.append(i[2])
+     
+    RNCG=min(charge)/sum([i for i in charge if i<0])
+    
+    
+    return  temp[charge.index(min(charge))]/RNCG
+    
+          
+
+def CalculateRPCS(ChargeSA):
+    """
+    #################################################################
+    The calculation of relative positive charge surface area
+    
+    -->RPCS
+    #################################################################
+    """
+    charge=[]
+    for i in ChargeSA:
+        charge.append(float(i[1]))
+    
+    temp=[]
+    for i in ChargeSA:
+        temp.append(i[2])
+     
+    RPCG=max(charge)/sum([i for i in charge if i>0])
+      
+    return  temp[charge.index(min(charge))]/RPCG
+    
+    
+############################################################################
+def GetCPSA():
+    """
+    #################################################################
+    Wrapper for the CPSA descriptors
+    #################################################################
+    """
+    ChargeSA=GetChargeSA(RadiusProbe=1.5,n_sphere_point=5000)
+    
+    res={}
+    res['ASA']=round(CalculateASA(ChargeSA),3)
+    res['MSA']=round(CalculateMSA(),3)
+    res['PNSA1']=round(CalculatePNSA1(ChargeSA),3)
+    res['PNSA2']=round(CalculatePNSA2(ChargeSA),3)
+    res['PNSA3']=round(CalculatePNSA3(ChargeSA),3)
+    res['PPSA1']=round(CalculatePPSA1(ChargeSA),3)
+    res['PPSA2']=round(CalculatePPSA2(ChargeSA),3)
+    res['PPSA3']=round(CalculatePPSA3(ChargeSA),3)
+    res['DPSA1']=round(CalculateDPSA1(ChargeSA),3)
+    res['DPSA2']=round(CalculateDPSA2(ChargeSA),3)
+    res['DPSA3']=round(CalculateDPSA3(ChargeSA),3)
+    res['FNSA1']=round(CalculateFNSA1(ChargeSA),3)
+    res['FNSA2']=round(CalculateFNSA2(ChargeSA),3)
+    res['FNSA3']=round(CalculateFNSA3(ChargeSA),3)
+    res['FPSA1']=round(CalculateFPSA1(ChargeSA),3)
+    res['FPSA2']=round(CalculateFPSA2(ChargeSA),3)
+    res['FPSA3']=round(CalculateFPSA3(ChargeSA),3)
+    res['WNSA1']=round(CalculateWNSA1(ChargeSA),3)
+    res['WNSA2']=round(CalculateWNSA2(ChargeSA),3)
+    res['WNSA3']=round(CalculateWNSA3(ChargeSA),3)
+    res['WPSA1']=round(CalculateWPSA1(ChargeSA),3)
+    res['WPSA2']=round(CalculateWPSA2(ChargeSA),3)
+    res['WPSA3']=round(CalculateWPSA3(ChargeSA),3)
+    res['TASA']=round(CalculateTASA(ChargeSA),3)
+    res['PSA']=round(CalculateTPSA(ChargeSA),3)
+    res['RASA']=round(CalculateRASA(ChargeSA),3)
+    res['RPSA']=round(CalculateRPSA(ChargeSA),3)
+    res['RNCS']=round(CalculateRNCS(ChargeSA),3)
+    res['RPCS']=round(CalculateRPCS(ChargeSA),3)
+    res['FrTATP']=round(CalculateFractionTATP(ChargeSA),3)
+
+
+    return res
+
+
+def _GetHTMLDoc():
+    """
+    #################################################################
+    Write HTML documentation for this module.
+    #################################################################
+    """
+    import pydoc
+    pydoc.writedoc('cpsa')
+#############################################################################    
+if __name__=="__main__":
+    
+    from .GeoOpt import GetARCFile
+    mol='C1C=CCS1'
+
+    inputmol=pybel.readstring('smi',mol)  
+    GetARCFile(inputmol)
+    result=GetCPSA()
+    print(result)
+    print(len(result))
diff -Naur pychem-1.0/src/pychem/estate.py pychem-1.0.3/src/pychem/estate.py
--- pychem-1.0/src/pychem/estate.py	2012-11-14 09:28:25.000000000 -0800
+++ pychem-1.0.3/src/pychem/estate.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,414 +1,414 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-This module is to compute the estate fingerprints and values based on Kier 
-
-and Hall's paper. If you have any question please contact me via email.
-
-My email adress is : orientalcds@gmail.com
-
-Created on Tue May 24 14:32:52 2011
-
-@author: Dongsheng Cao
-##############################################################################
-"""
-
-from rdkit.Chem.EState import Fingerprinter  as ESFP
-from rdkit import Chem
-
-import AtomTypes as ATEstate
-import numpy
-
-Version=1.0
-################################################################
-
-def _CalculateEState(mol,skipH=1):
-    """
-    #################################################################
-    **Internal used only**
-    
-    Get the EState value of each atom in a molecule
-    #################################################################
-    """
-    mol=Chem.AddHs(mol)
-    if skipH==1: 
-        mol=Chem.RemoveHs(mol)
-    tb1=Chem.GetPeriodicTable()
-    nAtoms=mol.GetNumAtoms()
-    Is=numpy.zeros(nAtoms,numpy.float)
-    for i in range(nAtoms):
-        at=mol.GetAtomWithIdx(i)
-        atNum=at.GetAtomicNum()
-        d=at.GetDegree()
-        if d>0:
-            h=at.GetTotalNumHs()
-            dv=tb1.GetNOuterElecs(atNum)-h         
-            #dv=numpy.array(_AtomHKDeltas(at),'d')
-            N=_GetPrincipleQuantumNumber(atNum)
-            Is[i]=(4.0/(N*N)*dv+1)/d
-    dists = Chem.GetDistanceMatrix(mol,useBO=0,useAtomWts=0)
-    dists +=1
-    accum = numpy.zeros(nAtoms,numpy.float)
-    for i in range(nAtoms):
-        for j in range(i+1,nAtoms):
-            p=dists[i,j]
-            if p < 1e6:
-                temp=(Is[i]-Is[j])/(p*p)
-                accum[i] +=temp
-                accum[j] -=temp
-    res=accum+Is
-    return res
-
-
-def _GetPrincipleQuantumNumber(atNum):
-    """
-    #################################################################
-    *Internal Use Only*
-    
-    Get the principle quantum number of atom with atomic
-    
-    number equal to atNum 
-    #################################################################
-    """
-    if atNum<=2:
-        return 1
-    elif atNum<=10:
-        return 2
-    elif atNum<=18:
-        return 3
-    elif atNum<=36:
-        return 4
-    elif atNum<=54:
-        return 5
-    elif atNum<=86:
-        return 6
-    else:
-        return 7
-
-
-
-def CalculateHeavyAtomEState(mol):
-    
-    """
-    #################################################################
-    The sum of the EState indices over all non-hydrogen atoms
-    
-    -->Shev
-    #################################################################
-    """
-    
-    return round(sum(_CalculateEState(mol)),3)
-
-def _CalculateAtomEState(mol,AtomicNum=6):
-    """
-    #################################################################
-    **Internal used only**
-    
-    The sum of the EState indices over all atoms 
-    #################################################################
-    """
-    nAtoms=mol.GetNumAtoms()
-    Is=numpy.zeros(nAtoms,numpy.float)
-    Estate=_CalculateEState(mol)
-    
-    for i in range(nAtoms):
-        at=mol.GetAtomWithIdx(i)
-        atNum=at.GetAtomicNum()
-        if atNum==AtomicNum:
-            Is[i]=Estate[i]
-            
-    res=sum(Is)
-    
-    return res
-    
-def CalculateCAtomEState(mol):
-    """
-    #################################################################
-    The sum of the EState indices over all C atoms
-    
-    -->Scar
-    #################################################################
-    """
-    return _CalculateAtomEState(mol,AtomicNum=6)
-
-
-
-def CalculateHalogenEState(mol):
-    
-    """
-    #################################################################
-    The sum of the EState indices over all Halogen atoms
-    
-    -->Shal
-    #################################################################
-    """
-    
-    Nf=_CalculateAtomEState(mol,AtomicNum=9)
-    Ncl=_CalculateAtomEState(mol,AtomicNum=17)
-    Nbr=_CalculateAtomEState(mol,AtomicNum=35)
-    Ni=_CalculateAtomEState(mol,AtomicNum=53)
-  
-    return round(Nf+Ncl+Nbr+Ni,3)
-
-
-
-def CalculateHeteroEState(mol):
-    """
-    #################################################################
-    The sum of the EState indices over all hetero atoms
-    
-    -->Shet
-    #################################################################
-    """
-    
-    Ntotal=sum(_CalculateEState(mol))
-    NC=_CalculateAtomEState(mol,AtomicNum=6)
-    NH=_CalculateAtomEState(mol,AtomicNum=1)
-    
-    return round(Ntotal-NC-NH,3)
-
-
-def CalculateAverageEState(mol):
-    """
-    #################################################################
-    The sum of the EState indices over all non-hydrogen atoms 
-    
-    divided by the number of non-hydrogen atoms.
-    
-    -->Save
-    #################################################################
-    """
-    N=mol.GetNumAtoms()
-    return round(sum(_CalculateEState(mol))/N,3)
-
-def CalculateMaxEState(mol):
-
-    """
-    #################################################################
-    Obtain the maximal Estate value in all atoms
-    
-    -->Smax
-    #################################################################
-    """
-    return round(max(_CalculateEState(mol)),3)
-
-
-def CalculateMinEState(mol):
-    """
-    #################################################################
-    Obtain the minimal Estate value in all atoms
-    
-    -->Smin
-    #################################################################
-    """
-    
-    return round(min(_CalculateEState(mol)),3)
-
-
-def CalculateDiffMaxMinEState(mol):
-    """
-    #################################################################
-    The difference between Smax and Smin
-    
-    -->DS
-    #################################################################
-    """
-    return round(max(_CalculateEState(mol))-min(_CalculateEState(mol)),3)
-    
-
-def CalculateAtomTypeEState(mol):
-    """
-    #################################################################
-    Calculation of sum of E-State value of specified atom type
-    
-    res---->list type
-    #################################################################
-    """
-    AT=ATEstate.GetAtomLabel(mol)
-    Estate=_CalculateEState(mol)
-    res=[]
-    for i in AT:
-        if i==[]:
-            res.append(0)
-        else:
-            res.append(sum([Estate[k] for k in i]))
-    ESresult={}
-    for n,es in enumerate(res):
-        ESresult['S'+str(n+1)]=round(es,3)
-        
-    return ESresult
-
-
-
-def CalculateEstateFingerprint(mol):
-    """
-    #################################################################
-    The Calculation of EState Fingerprints.
-    
-    It is the number of times each possible atom type is hit.
-    
-    Usage:
-        
-        result=CalculateEstateFingerprint(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a dict form containing 79 estate fragments.
-    #################################################################
-    """
-    temp=ESFP.FingerprintMol(mol)
-    res={}
-    for i,j in enumerate(temp[0]):
-        res['Sfinger'+str(i+1)]=j
-    
-    return res
-
-
-def CalculateEstateValue(mol):
-    """
-    #################################################################
-    The Calculate of EState Values.
-    
-    It is the sum of the Estate indices for atoms of each type.
-    
-    Usage:
-        
-        result=CalculateEstateValue(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a dict form containing 79 estate values.
-    #################################################################
-    """
-    temp=ESFP.FingerprintMol(mol)
-    res={}
-    for i,j in enumerate(temp[1]):
-        res['S'+str(i+1)]=round(j,3)
-    
-    return res
-        
-
-def CalculateMaxAtomTypeEState(mol):
-    """
-    #################################################################
-    Calculation of maximum of E-State value of specified atom type
-    
-    res---->dict type
-    
-    Usage:
-        
-        result=CalculateMaxAtomTypeEState(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a dict form containing 79 max estate values.
-    #################################################################
-    """
-    AT=ATEstate.GetAtomLabel(mol)
-    Estate=_CalculateEState(mol)
-    res=[]
-    for i in AT:
-        if i==[]:
-            res.append(0)
-        else:
-            res.append(max([Estate[k] for k in i]))
-    ESresult={}
-    for n,es in enumerate(res):
-        ESresult['Smax'+str(n)]=round(es,3)
-        
-    return ESresult
-
-
-
-def CalculateMinAtomTypeEState(mol):
-    """
-    #################################################################
-    Calculation of minimum of E-State value of specified atom type
-    
-    res---->dict type
-    
-    Usage:
-        
-        result=CalculateMinAtomTypeEState(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a dict form containing 79 min estate values.
-    #################################################################
-    """
-    AT=ATEstate.GetAtomLabel(mol)
-    Estate=_CalculateEState(mol)
-    res=[]
-    for i in AT:
-        if i==[]:
-            res.append(0)
-        else:
-            res.append(min([Estate[k] for k in i]))
-    ESresult={}
-    for n,es in enumerate(res):
-        ESresult['Smin'+str(n)]=round(es,3)
-        
-    return ESresult
-
-
-
-def GetEstate(mol):
-    """
-    #################################################################
-    Obtain all descriptors related to Estate.
-
-    Usage:
-        
-        result=GetEstate(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a dict form containing all estate values.
-    #################################################################
-    """
-    result={}
-    #result.update(CalculateEstateFingerprint(mol))
-    result.update(CalculateEstateValue(mol))
-    result.update(CalculateMaxAtomTypeEState(mol))
-    result.update(CalculateMinAtomTypeEState(mol))
-    result.update({'Shev':CalculateHeavyAtomEState(mol)})
-    result.update({'Scar':CalculateCAtomEState(mol)})
-    result.update({'Shal':CalculateHalogenEState(mol)})
-    result.update({'Shet':CalculateHeteroEState(mol)})
-    result.update({'Save':CalculateAverageEState(mol)})
-    result.update({'Smax':CalculateMaxEState(mol)})
-    result.update({'Smin':CalculateMinEState(mol)})
-    result.update({'DS':CalculateDiffMaxMinEState(mol)})
-
-    
-    return result
-
-
-def _GetHTMLDoc():
-    """
-    #################################################################
-    Write HTML documentation for this module.
-    #################################################################
-    """
-    import pydoc
-    pydoc.writedoc('estate')
-################################################################
-  
-if __name__=='__main__':
-    
-
-    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    for index, smi in enumerate(smis):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-##        print '\t',CalculateEstateFingerprint(m)
-##        print '\t',CalculateEstateValue(m)
-##        print '\t',CalculateMaxAtomTypeEState(m)
-##        print '\t', CalculateMinAtomTypeEState(m)
-        
-        print GetEstate(m)
-        print len(GetEstate(m))
-
-    
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+This module is to compute the estate fingerprints and values based on Kier 
+
+and Hall's paper. If you have any question please contact me via email.
+
+My email adress is : orientalcds@gmail.com
+
+Created on Tue May 24 14:32:52 2011
+
+@author: Dongsheng Cao
+##############################################################################
+"""
+
+from rdkit.Chem.EState import Fingerprinter  as ESFP
+from rdkit import Chem
+
+from . import AtomTypes as ATEstate
+import numpy
+
+Version=1.0
+################################################################
+
+def _CalculateEState(mol,skipH=1):
+    """
+    #################################################################
+    **Internal used only**
+    
+    Get the EState value of each atom in a molecule
+    #################################################################
+    """
+    mol=Chem.AddHs(mol)
+    if skipH==1: 
+        mol=Chem.RemoveHs(mol)
+    tb1=Chem.GetPeriodicTable()
+    nAtoms=mol.GetNumAtoms()
+    Is=numpy.zeros(nAtoms,numpy.float)
+    for i in range(nAtoms):
+        at=mol.GetAtomWithIdx(i)
+        atNum=at.GetAtomicNum()
+        d=at.GetDegree()
+        if d>0:
+            h=at.GetTotalNumHs()
+            dv=tb1.GetNOuterElecs(atNum)-h         
+            #dv=numpy.array(_AtomHKDeltas(at),'d')
+            N=_GetPrincipleQuantumNumber(atNum)
+            Is[i]=(4.0/(N*N)*dv+1)/d
+    dists = Chem.GetDistanceMatrix(mol,useBO=0,useAtomWts=0)
+    dists +=1
+    accum = numpy.zeros(nAtoms,numpy.float)
+    for i in range(nAtoms):
+        for j in range(i+1,nAtoms):
+            p=dists[i,j]
+            if p < 1e6:
+                temp=(Is[i]-Is[j])/(p*p)
+                accum[i] +=temp
+                accum[j] -=temp
+    res=accum+Is
+    return res
+
+
+def _GetPrincipleQuantumNumber(atNum):
+    """
+    #################################################################
+    *Internal Use Only*
+    
+    Get the principle quantum number of atom with atomic
+    
+    number equal to atNum 
+    #################################################################
+    """
+    if atNum<=2:
+        return 1
+    elif atNum<=10:
+        return 2
+    elif atNum<=18:
+        return 3
+    elif atNum<=36:
+        return 4
+    elif atNum<=54:
+        return 5
+    elif atNum<=86:
+        return 6
+    else:
+        return 7
+
+
+
+def CalculateHeavyAtomEState(mol):
+    
+    """
+    #################################################################
+    The sum of the EState indices over all non-hydrogen atoms
+    
+    -->Shev
+    #################################################################
+    """
+    
+    return round(sum(_CalculateEState(mol)),3)
+
+def _CalculateAtomEState(mol,AtomicNum=6):
+    """
+    #################################################################
+    **Internal used only**
+    
+    The sum of the EState indices over all atoms 
+    #################################################################
+    """
+    nAtoms=mol.GetNumAtoms()
+    Is=numpy.zeros(nAtoms,numpy.float)
+    Estate=_CalculateEState(mol)
+    
+    for i in range(nAtoms):
+        at=mol.GetAtomWithIdx(i)
+        atNum=at.GetAtomicNum()
+        if atNum==AtomicNum:
+            Is[i]=Estate[i]
+            
+    res=sum(Is)
+    
+    return res
+    
+def CalculateCAtomEState(mol):
+    """
+    #################################################################
+    The sum of the EState indices over all C atoms
+    
+    -->Scar
+    #################################################################
+    """
+    return _CalculateAtomEState(mol,AtomicNum=6)
+
+
+
+def CalculateHalogenEState(mol):
+    
+    """
+    #################################################################
+    The sum of the EState indices over all Halogen atoms
+    
+    -->Shal
+    #################################################################
+    """
+    
+    Nf=_CalculateAtomEState(mol,AtomicNum=9)
+    Ncl=_CalculateAtomEState(mol,AtomicNum=17)
+    Nbr=_CalculateAtomEState(mol,AtomicNum=35)
+    Ni=_CalculateAtomEState(mol,AtomicNum=53)
+  
+    return round(Nf+Ncl+Nbr+Ni,3)
+
+
+
+def CalculateHeteroEState(mol):
+    """
+    #################################################################
+    The sum of the EState indices over all hetero atoms
+    
+    -->Shet
+    #################################################################
+    """
+    
+    Ntotal=sum(_CalculateEState(mol))
+    NC=_CalculateAtomEState(mol,AtomicNum=6)
+    NH=_CalculateAtomEState(mol,AtomicNum=1)
+    
+    return round(Ntotal-NC-NH,3)
+
+
+def CalculateAverageEState(mol):
+    """
+    #################################################################
+    The sum of the EState indices over all non-hydrogen atoms 
+    
+    divided by the number of non-hydrogen atoms.
+    
+    -->Save
+    #################################################################
+    """
+    N=mol.GetNumAtoms()
+    return round(sum(_CalculateEState(mol))/N,3)
+
+def CalculateMaxEState(mol):
+
+    """
+    #################################################################
+    Obtain the maximal Estate value in all atoms
+    
+    -->Smax
+    #################################################################
+    """
+    return round(max(_CalculateEState(mol)),3)
+
+
+def CalculateMinEState(mol):
+    """
+    #################################################################
+    Obtain the minimal Estate value in all atoms
+    
+    -->Smin
+    #################################################################
+    """
+    
+    return round(min(_CalculateEState(mol)),3)
+
+
+def CalculateDiffMaxMinEState(mol):
+    """
+    #################################################################
+    The difference between Smax and Smin
+    
+    -->DS
+    #################################################################
+    """
+    return round(max(_CalculateEState(mol))-min(_CalculateEState(mol)),3)
+    
+
+def CalculateAtomTypeEState(mol):
+    """
+    #################################################################
+    Calculation of sum of E-State value of specified atom type
+    
+    res---->list type
+    #################################################################
+    """
+    AT=ATEstate.GetAtomLabel(mol)
+    Estate=_CalculateEState(mol)
+    res=[]
+    for i in AT:
+        if i==[]:
+            res.append(0)
+        else:
+            res.append(sum([Estate[k] for k in i]))
+    ESresult={}
+    for n,es in enumerate(res):
+        ESresult['S'+str(n+1)]=round(es,3)
+        
+    return ESresult
+
+
+
+def CalculateEstateFingerprint(mol):
+    """
+    #################################################################
+    The Calculation of EState Fingerprints.
+    
+    It is the number of times each possible atom type is hit.
+    
+    Usage:
+        
+        result=CalculateEstateFingerprint(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a dict form containing 79 estate fragments.
+    #################################################################
+    """
+    temp=ESFP.FingerprintMol(mol)
+    res={}
+    for i,j in enumerate(temp[0]):
+        res['Sfinger'+str(i+1)]=j
+    
+    return res
+
+
+def CalculateEstateValue(mol):
+    """
+    #################################################################
+    The Calculate of EState Values.
+    
+    It is the sum of the Estate indices for atoms of each type.
+    
+    Usage:
+        
+        result=CalculateEstateValue(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a dict form containing 79 estate values.
+    #################################################################
+    """
+    temp=ESFP.FingerprintMol(mol)
+    res={}
+    for i,j in enumerate(temp[1]):
+        res['S'+str(i+1)]=round(j,3)
+    
+    return res
+        
+
+def CalculateMaxAtomTypeEState(mol):
+    """
+    #################################################################
+    Calculation of maximum of E-State value of specified atom type
+    
+    res---->dict type
+    
+    Usage:
+        
+        result=CalculateMaxAtomTypeEState(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a dict form containing 79 max estate values.
+    #################################################################
+    """
+    AT=ATEstate.GetAtomLabel(mol)
+    Estate=_CalculateEState(mol)
+    res=[]
+    for i in AT:
+        if i==[]:
+            res.append(0)
+        else:
+            res.append(max([Estate[k] for k in i]))
+    ESresult={}
+    for n,es in enumerate(res):
+        ESresult['Smax'+str(n)]=round(es,3)
+        
+    return ESresult
+
+
+
+def CalculateMinAtomTypeEState(mol):
+    """
+    #################################################################
+    Calculation of minimum of E-State value of specified atom type
+    
+    res---->dict type
+    
+    Usage:
+        
+        result=CalculateMinAtomTypeEState(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a dict form containing 79 min estate values.
+    #################################################################
+    """
+    AT=ATEstate.GetAtomLabel(mol)
+    Estate=_CalculateEState(mol)
+    res=[]
+    for i in AT:
+        if i==[]:
+            res.append(0)
+        else:
+            res.append(min([Estate[k] for k in i]))
+    ESresult={}
+    for n,es in enumerate(res):
+        ESresult['Smin'+str(n)]=round(es,3)
+        
+    return ESresult
+
+
+
+def GetEstate(mol):
+    """
+    #################################################################
+    Obtain all descriptors related to Estate.
+
+    Usage:
+        
+        result=GetEstate(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a dict form containing all estate values.
+    #################################################################
+    """
+    result={}
+    #result.update(CalculateEstateFingerprint(mol))
+    result.update(CalculateEstateValue(mol))
+    result.update(CalculateMaxAtomTypeEState(mol))
+    result.update(CalculateMinAtomTypeEState(mol))
+    result.update({'Shev':CalculateHeavyAtomEState(mol)})
+    result.update({'Scar':CalculateCAtomEState(mol)})
+    result.update({'Shal':CalculateHalogenEState(mol)})
+    result.update({'Shet':CalculateHeteroEState(mol)})
+    result.update({'Save':CalculateAverageEState(mol)})
+    result.update({'Smax':CalculateMaxEState(mol)})
+    result.update({'Smin':CalculateMinEState(mol)})
+    result.update({'DS':CalculateDiffMaxMinEState(mol)})
+
+    
+    return result
+
+
+def _GetHTMLDoc():
+    """
+    #################################################################
+    Write HTML documentation for this module.
+    #################################################################
+    """
+    import pydoc
+    pydoc.writedoc('estate')
+################################################################
+  
+if __name__=='__main__':
+    
+
+    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    for index, smi in enumerate(smis):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+##        print '\t',CalculateEstateFingerprint(m)
+##        print '\t',CalculateEstateValue(m)
+##        print '\t',CalculateMaxAtomTypeEState(m)
+##        print '\t', CalculateMinAtomTypeEState(m)
+        
+        print(GetEstate(m))
+        print(len(GetEstate(m)))
+
+    
diff -Naur pychem-1.0/src/pychem/fingerprint.py pychem-1.0.3/src/pychem/fingerprint.py
--- pychem-1.0/src/pychem/fingerprint.py	2012-10-15 19:37:43.000000000 -0700
+++ pychem-1.0.3/src/pychem/fingerprint.py	2017-01-20 11:03:44.676668232 -0800
@@ -16,7 +16,7 @@
 from rdkit.Chem import MACCSkeys
 from rdkit.Chem import AllChem
 from rdkit import Chem
-from estate import CalculateEstateFingerprint as EstateFingerprint
+from .estate import CalculateEstateFingerprint as EstateFingerprint
 from rdkit.Chem.AtomPairs import Pairs
 from rdkit.Chem.AtomPairs import Torsions
 from rdkit import DataStructs
@@ -268,12 +268,12 @@
 
 if __name__=="__main__":
     
-    print "fingerprint......"
+    print("fingerprint......")
     
     ms = [Chem.MolFromSmiles('CCOC=N'), Chem.MolFromSmiles('CCO')]
     res1=CalculateTopologicalTorsionFingerprint(ms[0])
-    print res1
+    print(res1)
     res2=CalculateTopologicalTorsionFingerprint(ms[1])
-    print res2
-    print CalculateSimilarity(res1[2],res2[2])
-    
\ No newline at end of file
+    print(res2)
+    print(CalculateSimilarity(res1[2],res2[2]))
+    
diff -Naur pychem-1.0/src/pychem/geary.py pychem-1.0.3/src/pychem/geary.py
--- pychem-1.0/src/pychem/geary.py	2012-11-09 23:18:41.000000000 -0800
+++ pychem-1.0.3/src/pychem/geary.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,237 +1,237 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-The calculation of Geary autocorrelation indices based on its topological
-
-structure. You can get 32 molecular autocorrelation descriptors. You can 
-
-freely use and distribute it. If you hava  any problem, you could contact 
-
-with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.09.18
-
-Email: oriental-cds@163.com
-##############################################################################
-"""
-
-from rdkit import Chem
-from AtomProperty import GetRelativeAtomicProperty
-
-import numpy
-
-Version=1.0
-
-
-################################################################
-def _CalculateGearyAutocorrelation(mol,lag=1,propertylabel='m'):
-    """
-    #################################################################
-    **Internal used only**
-    
-    Calculation of Geary autocorrelation descriptors based on 
-    
-    different property weights.
-    
-    Usage:
-        
-    res=_CalculateGearyAutocorrelation(mol,lag=1,propertylabel='m')
-    
-    Input: mol is a molecule object.
-    
-    lag is the topological distance between atom i and atom j.
-    
-    propertylabel is the weighted property.
-    
-    Output: res is a numeric value.
-    #################################################################
-    """
-
-    Natom=mol.GetNumAtoms()
-    
-    prolist=[]
-    for i in mol.GetAtoms():
-        temp=GetRelativeAtomicProperty(i.GetSymbol(),propertyname=propertylabel)
-        prolist.append(temp)
-        
-    aveweight=sum(prolist)/Natom
-    
-    tempp=[numpy.square(x-aveweight) for x in prolist]   
-    
-    GetDistanceMatrix=Chem.GetDistanceMatrix(mol)
-    res=0.0
-    index=0
-    for i in range(Natom):
-        for j in range(Natom):  
-            if GetDistanceMatrix[i,j]==lag:
-                atom1=mol.GetAtomWithIdx(i)
-                atom2=mol.GetAtomWithIdx(j)
-                temp1=GetRelativeAtomicProperty(element=atom1.GetSymbol(),propertyname=propertylabel)
-                temp2=GetRelativeAtomicProperty(element=atom2.GetSymbol(),propertyname=propertylabel)
-                res=res+numpy.square(temp1-temp2)
-                index=index+1
-            else:
-                res=res+0.0
-                
-                
-    if sum(tempp)==0 or index==0:
-        result=0
-    else:
-        result=(res/index/2)/(sum(tempp)/(Natom-1))
-                
-    return round(result,3)
-
-
-def CalculateGearyAutoMass(mol):
-    """
-    #################################################################
-    Calculation of Geary autocorrelation descriptors based on 
-    
-    carbon-scaled atomic mass.
-    
-    Usage:
-    
-    res=CalculateMoranAutoMass(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight geary autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['GATSm'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='m')
-    
-    
-    return res
-
-
-def CalculateGearyAutoVolume(mol):
-    """
-    #################################################################
-    Calculation of Geary autocorrelation descriptors based on 
-    
-    carbon-scaled atomic van der Waals volume.
-
-    Usage:
-    
-    res=CalculateGearyAutoVolume(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight geary autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['GATSv'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='V')
-    
-    
-    return res
-
-def CalculateGearyAutoElectronegativity(mol):
-    """
-    #################################################################
-    Calculation of Geary autocorrelation descriptors based on 
-    
-    carbon-scaled atomic Sanderson electronegativity.
-    
-    Usage:
-    
-    res=CalculateGearyAutoElectronegativity(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight geary autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['GATSe'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='En')
-    
-    
-    return res
-
-def CalculateGearyAutoPolarizability(mol):
-    """
-    #################################################################
-    Calculation of Geary autocorrelation descriptors based on 
-    
-    carbon-scaled atomic polarizability.
-    
-    Usage:
-    
-    res=CalculateGearyAutoPolarizability(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight geary autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['GATSp'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='alapha')
-    
-    
-    return res
-
-
-def GetGearyAuto(mol):
-    """
-    #################################################################
-    Calcualate all Geary autocorrelation descriptors.
-
-    (carbon-scaled atomic mass, carbon-scaled atomic van der Waals volume,
-     
-    carbon-scaled atomic Sanderson electronegativity,
-     
-    carbon-scaled atomic polarizability)
-    
-    Usage:
-    
-    res=GetGearyAuto(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing all geary autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    res.update(CalculateGearyAutoMass(mol))
-    res.update(CalculateGearyAutoVolume(mol))
-    res.update(CalculateGearyAutoElectronegativity(mol))
-    res.update(CalculateGearyAutoPolarizability(mol))
-    
-    return res
-###########################################################################
-if __name__=='__main__':
-    
-    
-    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    for index, smi in enumerate(smi5):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-##        print '\t',CalculateEstateFingerprint(m)
-##        print '\t',CalculateEstateValue(m)
-##        print '\t',CalculateMaxAtomTypeEState(m)
-##        print '\t', CalculateMinAtomTypeEState(m)
-        
-        print GetGearyAuto(m)
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+The calculation of Geary autocorrelation indices based on its topological
+
+structure. You can get 32 molecular autocorrelation descriptors. You can 
+
+freely use and distribute it. If you hava  any problem, you could contact 
+
+with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.09.18
+
+Email: oriental-cds@163.com
+##############################################################################
+"""
+
+from rdkit import Chem
+from .AtomProperty import GetRelativeAtomicProperty
+
+import numpy
+
+Version=1.0
+
+
+################################################################
+def _CalculateGearyAutocorrelation(mol,lag=1,propertylabel='m'):
+    """
+    #################################################################
+    **Internal used only**
+    
+    Calculation of Geary autocorrelation descriptors based on 
+    
+    different property weights.
+    
+    Usage:
+        
+    res=_CalculateGearyAutocorrelation(mol,lag=1,propertylabel='m')
+    
+    Input: mol is a molecule object.
+    
+    lag is the topological distance between atom i and atom j.
+    
+    propertylabel is the weighted property.
+    
+    Output: res is a numeric value.
+    #################################################################
+    """
+
+    Natom=mol.GetNumAtoms()
+    
+    prolist=[]
+    for i in mol.GetAtoms():
+        temp=GetRelativeAtomicProperty(i.GetSymbol(),propertyname=propertylabel)
+        prolist.append(temp)
+        
+    aveweight=sum(prolist)/Natom
+    
+    tempp=[numpy.square(x-aveweight) for x in prolist]   
+    
+    GetDistanceMatrix=Chem.GetDistanceMatrix(mol)
+    res=0.0
+    index=0
+    for i in range(Natom):
+        for j in range(Natom):  
+            if GetDistanceMatrix[i,j]==lag:
+                atom1=mol.GetAtomWithIdx(i)
+                atom2=mol.GetAtomWithIdx(j)
+                temp1=GetRelativeAtomicProperty(element=atom1.GetSymbol(),propertyname=propertylabel)
+                temp2=GetRelativeAtomicProperty(element=atom2.GetSymbol(),propertyname=propertylabel)
+                res=res+numpy.square(temp1-temp2)
+                index=index+1
+            else:
+                res=res+0.0
+                
+                
+    if sum(tempp)==0 or index==0:
+        result=0
+    else:
+        result=(res/index/2)/(sum(tempp)/(Natom-1))
+                
+    return round(result,3)
+
+
+def CalculateGearyAutoMass(mol):
+    """
+    #################################################################
+    Calculation of Geary autocorrelation descriptors based on 
+    
+    carbon-scaled atomic mass.
+    
+    Usage:
+    
+    res=CalculateMoranAutoMass(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight geary autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['GATSm'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='m')
+    
+    
+    return res
+
+
+def CalculateGearyAutoVolume(mol):
+    """
+    #################################################################
+    Calculation of Geary autocorrelation descriptors based on 
+    
+    carbon-scaled atomic van der Waals volume.
+
+    Usage:
+    
+    res=CalculateGearyAutoVolume(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight geary autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['GATSv'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='V')
+    
+    
+    return res
+
+def CalculateGearyAutoElectronegativity(mol):
+    """
+    #################################################################
+    Calculation of Geary autocorrelation descriptors based on 
+    
+    carbon-scaled atomic Sanderson electronegativity.
+    
+    Usage:
+    
+    res=CalculateGearyAutoElectronegativity(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight geary autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['GATSe'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='En')
+    
+    
+    return res
+
+def CalculateGearyAutoPolarizability(mol):
+    """
+    #################################################################
+    Calculation of Geary autocorrelation descriptors based on 
+    
+    carbon-scaled atomic polarizability.
+    
+    Usage:
+    
+    res=CalculateGearyAutoPolarizability(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight geary autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['GATSp'+str(i+1)]=_CalculateGearyAutocorrelation(mol,lag=i+1,propertylabel='alapha')
+    
+    
+    return res
+
+
+def GetGearyAuto(mol):
+    """
+    #################################################################
+    Calcualate all Geary autocorrelation descriptors.
+
+    (carbon-scaled atomic mass, carbon-scaled atomic van der Waals volume,
+     
+    carbon-scaled atomic Sanderson electronegativity,
+     
+    carbon-scaled atomic polarizability)
+    
+    Usage:
+    
+    res=GetGearyAuto(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing all geary autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    res.update(CalculateGearyAutoMass(mol))
+    res.update(CalculateGearyAutoVolume(mol))
+    res.update(CalculateGearyAutoElectronegativity(mol))
+    res.update(CalculateGearyAutoPolarizability(mol))
+    
+    return res
+###########################################################################
+if __name__=='__main__':
+    
+    
+    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    for index, smi in enumerate(smi5):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+##        print '\t',CalculateEstateFingerprint(m)
+##        print '\t',CalculateEstateValue(m)
+##        print '\t',CalculateMaxAtomTypeEState(m)
+##        print '\t', CalculateMinAtomTypeEState(m)
+        
+        print(GetGearyAuto(m))
diff -Naur pychem-1.0/src/pychem/geometric.py pychem-1.0.3/src/pychem/geometric.py
--- pychem-1.0/src/pychem/geometric.py	2012-11-14 06:01:01.000000000 -0800
+++ pychem-1.0.3/src/pychem/geometric.py	2017-01-20 11:03:44.676668232 -0800
@@ -1,534 +1,534 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-This module is to compute geometrical descriptors based on the optimized
-
-molecular structure by MOPAC.If you have any question please contact me
-
-via email.
-
-Created on Tue Apr 19 11:37:14 2011
-
-@author: Dongsheng Cao
-##############################################################################
-"""
-
-import pybel
-import scipy
-#import scipy.linalg
-from GeoOpt import _ReadCoordinates
-
-import math
-
-Version=1.0
-############################################################################
-            
-    
-def GetAtomDistance(x,y):
-    """
-    #################################################################
-    Obtain the Elucidian distance based on the coordinates of two atoms
-    #################################################################
-    """
-
-    temp=[math.pow(x[0]-y[0],2),math.pow(x[1]-y[1],2),math.pow(x[2]-y[2],2)]
-    res=scipy.sqrt(sum(temp))
-    return res
-
-
-def GetGementricalDistanceMatrix(CoordinateList):
-    """
-    #################################################################
-    Obtain the distance matrix of a molecule based on coordinate list
-    #################################################################
-    """
-    NAtom=len(CoordinateList)
-    DistanceMatrix=scipy.zeros((NAtom,NAtom))
-    for i in range(NAtom-1):
-        for j in range(i+1,NAtom):
-            DistanceMatrix[i,j]=GetAtomDistance(CoordinateList[i],CoordinateList[j])
-            DistanceMatrix[j,i]=DistanceMatrix[i,j]
-    return DistanceMatrix
- 
-
-           
-def _GetMassCenter(MassCoordinates):
-    
-    """
-    #################################################################
-    Get the center of mass.
-    INPUT: MassCoordinates is [[atommass,[x,y,z]],......].
-    #################################################################
-    """
-    
-    res1=0.0
-    res2=0.0
-    res3=0.0
-    temp=[]
-    for i in MassCoordinates:
-        res1=res1+i[0]*i[1][0]
-        res2=res2+i[0]*i[1][1]
-        res3=res3+i[0]*i[1][2]
-        temp.append(i[0])
-    result=[res1/sum(temp),res2/sum(temp),res3/sum(temp)]
-    return result
-    
-
-def _GetGeometricalCenter(ChargeCoordinates):
-    """
-    #################################################################
-    Get the geometrical center
-    #################################################################
-    """
-    res1=[]
-    res2=[]
-    res3=[]
-
-    for i in ChargeCoordinates:
-        res1.append(float(i[1]))
-        res2.append(float(i[2]))
-        res3.append(float(i[3]))
-    
-    result=[scipy.mean(res1),scipy.mean(res2),scipy.mean(res3)]
-    
-    return result    
-
-
-def Calculate3DWienerWithH(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of 3-D Wiener index based gemetrical distance matrix optimized
-    by MOPAC(including Hs)
-    -->W3DH
-    #################################################################
-    """
-    temp=[]
-    for i in ChargeCoordinates:        
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-    
-    DistanceMatrix=GetGementricalDistanceMatrix(temp)
-   
-    return round(scipy.sum(DistanceMatrix)/2.0,3)
-
-
-def Calculate3DWienerWithoutH(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of 3-D Wiener index based 
-    gemetrical distance matrix optimized
-    by MOPAC(Not including Hs) 
-    -->W3D
-    #################################################################
-    """
-    temp=[]
-    for i in ChargeCoordinates:
-        if i[0]!='H':
-            temp.append([float(i[1]),float(i[2]),float(i[3])])
-    
-    DistanceMatrix=GetGementricalDistanceMatrix(temp)
-   
-    return round(scipy.sum(DistanceMatrix)/2.0,3)
-
-
-        
-def CalculatePetitjean3DIndex(ChargeCoordinates):
-    """
-    #################################################################
-    CalculatePetitjean Index based on molecular gemetrical distance matrix
-    -->Petitj3D
-    The 3D Petitjean shape index (PJI3) is calculated 
-    dividing the difference between geometric diameter and 
-    radius by the geometric radius [P.A. Bath, A.R. Poirrette, 
-    P. Willett, F.H. Allen, J.Chem.Inf.Comput.Sci. 1995, 35, 714-716]. 
-    The geometric radius of a molecule is defined as the minimum 
-    geometric eccentricity and the diameter is defined as the 
-    maximum geometric eccentricity in the molecule, the atom 
-    geometric eccentricity being the longest geometric distance 
-    from the considered atom to any other atom in the molecule. 
-    #################################################################
-    """
-    temp=[]
-    for i in ChargeCoordinates:        
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-    
-    DistanceMatrix=GetGementricalDistanceMatrix(temp)    
-    temp1=scipy.amax(DistanceMatrix,axis=0)
-    
-    return round(max(temp1)/min(temp1)-1.0,3)
-
-
-def CalculateGemetricalDiameter(ChargeCoordinates):
-    """
-    #################################################################
-    The longest distance between two atoms (gemetrical diameter)
-    -->GeDi
-    #################################################################
-    """
-    temp=[]
-    for i in ChargeCoordinates:        
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-
-    DistanceMatrix=GetGementricalDistanceMatrix(temp)    
-    temp1=scipy.amax(DistanceMatrix,axis=0)
-    
-    return round(max(temp1),3)
-
-
-def CalculateTopoElectronic(ChargeCoordinates):
-    """
-    #################################################################
-    #################################################################
-    """
-    pass
-
-
-
-def CalculateGravitational3D1(mol,ChargeCoordinates):
-    
-    """
-    #################################################################
-    Calculation of Gravitational 3D index.
-    --->grav1
-    #################################################################
-    """
-    mol.removeh()
-    mol.addh()
-    temp=[]  
-    for i,j in enumerate(ChargeCoordinates):        
-        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])
-    
-    
-    nAT=len(temp)
-    result=0.0
-    for i in range(nAT-1):
-        for j in range(i+1,nAT):
-            dis=GetAtomDistance(temp[i][1],temp[j][1])
-            
-            result=result+temp[i][0]*temp[j][0]/scipy.power(dis,p=2)
-    
-    return round(float(result)/100,3)
-            
-
-def CalculateGravitational3D2((mol,ChargeCoordinates)):
-    """
-    #################################################################
-    Gravitational indices are molecular descriptors 
-    reflecting the mass distribution in a molecule, 
-    defined as [A.R. Katritzky, L. Mu, V.S. Lobanov,
-    M. Karelson, J.Phys.Chem. 1996, 100, 10400-10407]
-    ---->grav2
-    #################################################################
-    """
-    pass
-        
-
-
-def CalculateRadiusofGyration(mol,ChargeCoordinates):
-    
-    """
-    #################################################################
-    Calculation of Radius of gyration. 
-    --->rygr
-    #################################################################
-    """
-    mol.addh()
-    temp=[]  
-    for i,j in enumerate(ChargeCoordinates):        
-        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])
-    nAT=len(temp)
-    
-    
-    masscenter=_GetMassCenter(temp)
-    result=0.0
-    for i in range(nAT):
-        dis=GetAtomDistance(temp[i][1],masscenter)
-        result=result+temp[i][0]*scipy.power(dis,p=2)
-    
-    
-    return round(scipy.sqrt(float(result/mol.molwt)),3)
-    
-
-
-
-def GetInertiaMatrix(mol,ChargeCoordinates):
-    """
-    #################################################################
-    Get Inertia matrix based on atomic mass and optimized coordinates.
-    #################################################################
-    """
-    mol.removeh()
-    mol.addh()
-    
-    temp=[]  
-    for i,j in enumerate(ChargeCoordinates):        
-        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])   
-#     
-#    masscenter=_GetMassCenter(temp)  
-#    
-#    for i,j in enumerate(temp):
-#        temp[i][1]=[d-masscenter[k] for k,d in enumerate(j[1])]     
-     
-
-    nAT=len(temp)    
-    
-    InertiaMatrix=scipy.zeros((3,3))
-    res11=0.0
-    res22=0.0
-    res33=0.0
-    res12=0.0
-    res23=0.0
-    res13=0.0
-    for i in range(nAT):
-        res11=res11+temp[i][0]*(math.pow(temp[i][1][1],2)+math.pow(temp[i][1][2],2))
-        res22=res22+temp[i][0]*(math.pow(temp[i][1][0],2)+math.pow(temp[i][1][2],2))
-        res33=res33+temp[i][0]*(math.pow(temp[i][1][0],2)+math.pow(temp[i][1][1],2))
-        res12=res12+temp[i][0]*(temp[i][1][0]*temp[i][1][1])
-        res13=res13+temp[i][0]*(temp[i][1][0]*temp[i][1][2])
-        res23=res23+temp[i][0]*(temp[i][1][1]*temp[i][1][2])
-    InertiaMatrix[0,0]=res11
-    InertiaMatrix[1,1]=res22
-    InertiaMatrix[2,2]=res33
-    InertiaMatrix[0,1]=res12
-    InertiaMatrix[0,2]=res13
-    InertiaMatrix[1,2]=res23
-    InertiaMatrix[1,0]=res12
-    InertiaMatrix[2,0]=res13
-    InertiaMatrix[2,1]=res23
-    
-    return InertiaMatrix
-    
-        
-
-
-def CalculatePrincipalMomentofInertia(mol,ChargeCoordinates):
-    """
-    #################################################################
-    X,Y and Z-principal geometric moment.   
-    drived from ADAPT developed by Jurs.
-    #################################################################
-    """
-    InertiaMatrix=GetInertiaMatrix(mol,ChargeCoordinates)
-    ma=scipy.mean(InertiaMatrix,axis=1)
-    ms=scipy.std(InertiaMatrix,axis=1,ddof=1)
-    bb=scipy.ones((3,1))
-    InertiaMatrix=(InertiaMatrix-bb*ma.T)/(bb*ms.T)  
-    u,s,v=scipy.linalg.svd(InertiaMatrix)
-
-    res={}
-    res['IA']=round(s[2],3)
-    res['IB']=round(s[1],3)
-    res['IC']=round(s[0],3)
-    
-    return res
-    
-        
-def CalculateRatioPMI(mol,ChargeCoordinates):
-    """
-    #################################################################
-    The ratio of X/Y, Y/Z and X/Z (principal moment of inertia)
-    drived from ADAPT developed by Jurs.
-    #################################################################
-    """
-    temp=CalculatePrincipalMomentofInertia(mol,ChargeCoordinates)
-    res={}
-        
-    res['IA/B']=round(temp['IA']/temp['IB'],3)
-    res['IA/C']=round(temp['IA']/temp['IC'],3)
-    res['IB/C']=round(temp['IB']/temp['IC'],3)
-    return res
-
-
-
-
-
-
-def CalculateHarary3D(ChargeCoordinates):
-    """
-    #################################################################
-    The 3D-Harary index (H3D) is calculated as 
-    the sum of all the reciprocal geometric distances 
-    in a molecule. 
-    --->Harary3D
-    #################################################################
-    """
-    temp=[]
-    for i in ChargeCoordinates:       
-        temp.append([float(i[1]),float(i[2]),float(i[3])])    
-    DistanceMatrix=GetGementricalDistanceMatrix(temp) 
-    nAT=len(temp)
-    res=0.0
-    for i in range(nAT-1):
-        for j in range(i+1,nAT):
-            if DistanceMatrix[i,j]==0:
-                cds=0.0
-            else:
-                cds=1./DistanceMatrix[i,j]
-            res=res+cds
-    return round(res,3)
-            
-            
-
-
-def CalculateAverageGeometricalDistanceDegree(ChargeCoordinates):
-    """
-    #################################################################
-    The average geometric distance degree (AGDD) is 
-    calculated dividing the sum of all geometric distance 
-    degrees by the total number of molecule atoms (nAT). 
-    ---->AGDD
-    #################################################################
-    """
-    temp=[]
-    for i in ChargeCoordinates:       
-        temp.append([float(i[1]),float(i[2]),float(i[3])])    
-    DistanceMatrix=GetGementricalDistanceMatrix(temp) 
-    nAT=len(temp)
-    
-    res=sum(sum(DistanceMatrix))/nAT
-    
-    return round(res,3)
-    
-
-
-def CalculateAbsEigenvalueSumOnGeometricMatrix(ChargeCoordinates):
-    """
-    #################################################################
-    The absolute eigenvalue sum on geometry matrix (SEig) 
-    is the sum of the absolute eigenvalues of the geometry matrix. 
-    --->SEig
-    #################################################################
-    """
-    temp=[]
-    for i in ChargeCoordinates:       
-        temp.append([float(i[1]),float(i[2]),float(i[3])])    
-    DistanceMatrix=GetGementricalDistanceMatrix(temp) 
-    
-    u,s,vt=scipy.linalg.svd(DistanceMatrix)
-    
-    return round(sum(abs(s)),3)
-
-
-def CalculateSPANR(mol,ChargeCoordinates):
-    """
-    #################################################################
-    The span R (SPAN) is a size descriptor defined as 
-    the radius of the smallest sphere, centred on the centre 
-    of mass, completely enclosing all atoms of a molecule 
-    [G.A. Arteca, Molecular Shape Descriptors in Reviews in 
-    Computational Chemistry - Vol. 9, K.B. Lipkowitz, D. Boyd (Eds.), 
-    VCH Publishers, New York (NY), pp. 191-253, 1991]
-    --->SPAN
-    #################################################################
-    """
-    mol.removeh()
-    mol.addh()
-    temp=[]  
-    for i,j in enumerate(ChargeCoordinates):        
-        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])   
-     
-    masscenter=_GetMassCenter(temp)  
-    
-    res=[]
-    for i in temp:
-        res.append(GetAtomDistance(i[1],masscenter)) 
-
-    return round(float(max(res)),3)
-
-
-def CalculateAverageSPANR(mol,ChargeCoordinates):
-    """
-    #################################################################
-    The average span R (SPAM) is the root square of 
-    the ratio of SPAN over the number of atoms.
-    --->ASPAN
-    #################################################################
-    """
-    mol.removeh()
-    mol.addh()
-    temp=[]  
-    for i,j in enumerate(ChargeCoordinates):        
-        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])   
-    
-    nAT=len(temp)
-    masscenter=_GetMassCenter(temp)      
-    res=[]
-    for i in temp:
-        res.append(GetAtomDistance(i[1],masscenter)) 
-
-    return round(math.pow(float(max(res))/nAT,0.5),3)
-
-
-def CalculateMolecularEccentricity(mol,ChargeCoordinates):
-    """
-    #################################################################
-    The molecular eccentricity (MEcc) is a shape descriptor 
-    calculated from the eigenvalues l of the molecular inertia matrix 
-    [G.A. Arteca, Molecular Shape Descriptors in Reviews 
-    in Computational Chemistry - Vol. 9, K.B. Lipkowitz, D. Boyd (Eds.), 
-    VCH Publishers, New York (NY), pp. 191-253, 1991].
-    --->MEcc
-    #################################################################
-    """
-    InertiaMatrix=GetInertiaMatrix(mol,ChargeCoordinates)
-    u,s,v=scipy.linalg.svd(InertiaMatrix)
-    
-    res1=s[0]
-    res3=s[2]
-    
-    res=math.pow(res1*res1-res3*res3,1./2)/res1
-    return round(res,3)
-    
-
-
-
-#############################################################################    
-
-def GetGeometric(mol):
-    """
-    #################################################################
-    Wrapper for Geometrical descriptors
-    #################################################################
-    """
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename)
-    res={}
-    res['W3DH']=Calculate3DWienerWithH(ChargeCoordinates)
-    res['W3D']=Calculate3DWienerWithoutH(ChargeCoordinates)
-    res['Petitj3D']=CalculatePetitjean3DIndex(ChargeCoordinates)
-    res['GeDi']=CalculateGemetricalDiameter(ChargeCoordinates)
-    res['grav']=CalculateGravitational3D1(mol,ChargeCoordinates)
-    res['rygr']=CalculateRadiusofGyration(mol,ChargeCoordinates)
-    res['Harary3D']=CalculateHarary3D(ChargeCoordinates)
-    res['AGDD']=CalculateAverageGeometricalDistanceDegree(ChargeCoordinates)
-    res['SEig']=CalculateAbsEigenvalueSumOnGeometricMatrix(ChargeCoordinates)
-    res['SPAN']=CalculateSPANR(mol,ChargeCoordinates)
-    res['ASPAN']=CalculateAverageSPANR(mol,ChargeCoordinates)
-    res['MEcc']=CalculateMolecularEccentricity(mol,ChargeCoordinates)
-    #res.update(CalculatePrincipalMomentofInertia(mol,ChargeCoordinates))
-    #res.update(CalculateRatioPMI(mol,ChargeCoordinates))
-    
-    return res
-
-def _GetHTMLDoc():
-    """
-    #################################################################
-    Write HTML documentation for this module.
-    #################################################################
-    """
-    import pydoc
-    pydoc.writedoc('geometric')
-    
-#############################################################################
-if __name__=="__main__":
-    
-    
-    from GeoOpt import GetARCFile
-    mol='C1C=CCCS1'
-    mol='ClC(Cl)(Cl)Cl'
-
-
-    inputmol=pybel.readstring('smi',mol)  
-    GetARCFile(inputmol)
-    result=GetGeometric(inputmol)
-    print result
-    print len(result)
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+This module is to compute geometrical descriptors based on the optimized
+
+molecular structure by MOPAC.If you have any question please contact me
+
+via email.
+
+Created on Tue Apr 19 11:37:14 2011
+
+@author: Dongsheng Cao
+##############################################################################
+"""
+
+import pybel
+import scipy
+#import scipy.linalg
+from .GeoOpt import _ReadCoordinates
+
+import math
+
+Version=1.0
+############################################################################
+            
+    
+def GetAtomDistance(x,y):
+    """
+    #################################################################
+    Obtain the Elucidian distance based on the coordinates of two atoms
+    #################################################################
+    """
+
+    temp=[math.pow(x[0]-y[0],2),math.pow(x[1]-y[1],2),math.pow(x[2]-y[2],2)]
+    res=scipy.sqrt(sum(temp))
+    return res
+
+
+def GetGementricalDistanceMatrix(CoordinateList):
+    """
+    #################################################################
+    Obtain the distance matrix of a molecule based on coordinate list
+    #################################################################
+    """
+    NAtom=len(CoordinateList)
+    DistanceMatrix=scipy.zeros((NAtom,NAtom))
+    for i in range(NAtom-1):
+        for j in range(i+1,NAtom):
+            DistanceMatrix[i,j]=GetAtomDistance(CoordinateList[i],CoordinateList[j])
+            DistanceMatrix[j,i]=DistanceMatrix[i,j]
+    return DistanceMatrix
+ 
+
+           
+def _GetMassCenter(MassCoordinates):
+    
+    """
+    #################################################################
+    Get the center of mass.
+    INPUT: MassCoordinates is [[atommass,[x,y,z]],......].
+    #################################################################
+    """
+    
+    res1=0.0
+    res2=0.0
+    res3=0.0
+    temp=[]
+    for i in MassCoordinates:
+        res1=res1+i[0]*i[1][0]
+        res2=res2+i[0]*i[1][1]
+        res3=res3+i[0]*i[1][2]
+        temp.append(i[0])
+    result=[res1/sum(temp),res2/sum(temp),res3/sum(temp)]
+    return result
+    
+
+def _GetGeometricalCenter(ChargeCoordinates):
+    """
+    #################################################################
+    Get the geometrical center
+    #################################################################
+    """
+    res1=[]
+    res2=[]
+    res3=[]
+
+    for i in ChargeCoordinates:
+        res1.append(float(i[1]))
+        res2.append(float(i[2]))
+        res3.append(float(i[3]))
+    
+    result=[scipy.mean(res1),scipy.mean(res2),scipy.mean(res3)]
+    
+    return result    
+
+
+def Calculate3DWienerWithH(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of 3-D Wiener index based gemetrical distance matrix optimized
+    by MOPAC(including Hs)
+    -->W3DH
+    #################################################################
+    """
+    temp=[]
+    for i in ChargeCoordinates:        
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+    
+    DistanceMatrix=GetGementricalDistanceMatrix(temp)
+   
+    return round(scipy.sum(DistanceMatrix)/2.0,3)
+
+
+def Calculate3DWienerWithoutH(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of 3-D Wiener index based 
+    gemetrical distance matrix optimized
+    by MOPAC(Not including Hs) 
+    -->W3D
+    #################################################################
+    """
+    temp=[]
+    for i in ChargeCoordinates:
+        if i[0]!='H':
+            temp.append([float(i[1]),float(i[2]),float(i[3])])
+    
+    DistanceMatrix=GetGementricalDistanceMatrix(temp)
+   
+    return round(scipy.sum(DistanceMatrix)/2.0,3)
+
+
+        
+def CalculatePetitjean3DIndex(ChargeCoordinates):
+    """
+    #################################################################
+    CalculatePetitjean Index based on molecular gemetrical distance matrix
+    -->Petitj3D
+    The 3D Petitjean shape index (PJI3) is calculated 
+    dividing the difference between geometric diameter and 
+    radius by the geometric radius [P.A. Bath, A.R. Poirrette, 
+    P. Willett, F.H. Allen, J.Chem.Inf.Comput.Sci. 1995, 35, 714-716]. 
+    The geometric radius of a molecule is defined as the minimum 
+    geometric eccentricity and the diameter is defined as the 
+    maximum geometric eccentricity in the molecule, the atom 
+    geometric eccentricity being the longest geometric distance 
+    from the considered atom to any other atom in the molecule. 
+    #################################################################
+    """
+    temp=[]
+    for i in ChargeCoordinates:        
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+    
+    DistanceMatrix=GetGementricalDistanceMatrix(temp)    
+    temp1=scipy.amax(DistanceMatrix,axis=0)
+    
+    return round(max(temp1)/min(temp1)-1.0,3)
+
+
+def CalculateGemetricalDiameter(ChargeCoordinates):
+    """
+    #################################################################
+    The longest distance between two atoms (gemetrical diameter)
+    -->GeDi
+    #################################################################
+    """
+    temp=[]
+    for i in ChargeCoordinates:        
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+
+    DistanceMatrix=GetGementricalDistanceMatrix(temp)    
+    temp1=scipy.amax(DistanceMatrix,axis=0)
+    
+    return round(max(temp1),3)
+
+
+def CalculateTopoElectronic(ChargeCoordinates):
+    """
+    #################################################################
+    #################################################################
+    """
+    pass
+
+
+
+def CalculateGravitational3D1(mol,ChargeCoordinates):
+    
+    """
+    #################################################################
+    Calculation of Gravitational 3D index.
+    --->grav1
+    #################################################################
+    """
+    mol.removeh()
+    mol.addh()
+    temp=[]  
+    for i,j in enumerate(ChargeCoordinates):        
+        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])
+    
+    
+    nAT=len(temp)
+    result=0.0
+    for i in range(nAT-1):
+        for j in range(i+1,nAT):
+            dis=GetAtomDistance(temp[i][1],temp[j][1])
+            
+            result=result+temp[i][0]*temp[j][0]/scipy.power(dis,p=2)
+    
+    return round(float(result)/100,3)
+            
+
+def CalculateGravitational3D2(mol,ChargeCoordinates):
+    """
+    #################################################################
+    Gravitational indices are molecular descriptors 
+    reflecting the mass distribution in a molecule, 
+    defined as [A.R. Katritzky, L. Mu, V.S. Lobanov,
+    M. Karelson, J.Phys.Chem. 1996, 100, 10400-10407]
+    ---->grav2
+    #################################################################
+    """
+    pass
+        
+
+
+def CalculateRadiusofGyration(mol,ChargeCoordinates):
+    
+    """
+    #################################################################
+    Calculation of Radius of gyration. 
+    --->rygr
+    #################################################################
+    """
+    mol.addh()
+    temp=[]  
+    for i,j in enumerate(ChargeCoordinates):        
+        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])
+    nAT=len(temp)
+    
+    
+    masscenter=_GetMassCenter(temp)
+    result=0.0
+    for i in range(nAT):
+        dis=GetAtomDistance(temp[i][1],masscenter)
+        result=result+temp[i][0]*scipy.power(dis,p=2)
+    
+    
+    return round(scipy.sqrt(float(result/mol.molwt)),3)
+    
+
+
+
+def GetInertiaMatrix(mol,ChargeCoordinates):
+    """
+    #################################################################
+    Get Inertia matrix based on atomic mass and optimized coordinates.
+    #################################################################
+    """
+    mol.removeh()
+    mol.addh()
+    
+    temp=[]  
+    for i,j in enumerate(ChargeCoordinates):        
+        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])   
+#     
+#    masscenter=_GetMassCenter(temp)  
+#    
+#    for i,j in enumerate(temp):
+#        temp[i][1]=[d-masscenter[k] for k,d in enumerate(j[1])]     
+     
+
+    nAT=len(temp)    
+    
+    InertiaMatrix=scipy.zeros((3,3))
+    res11=0.0
+    res22=0.0
+    res33=0.0
+    res12=0.0
+    res23=0.0
+    res13=0.0
+    for i in range(nAT):
+        res11=res11+temp[i][0]*(math.pow(temp[i][1][1],2)+math.pow(temp[i][1][2],2))
+        res22=res22+temp[i][0]*(math.pow(temp[i][1][0],2)+math.pow(temp[i][1][2],2))
+        res33=res33+temp[i][0]*(math.pow(temp[i][1][0],2)+math.pow(temp[i][1][1],2))
+        res12=res12+temp[i][0]*(temp[i][1][0]*temp[i][1][1])
+        res13=res13+temp[i][0]*(temp[i][1][0]*temp[i][1][2])
+        res23=res23+temp[i][0]*(temp[i][1][1]*temp[i][1][2])
+    InertiaMatrix[0,0]=res11
+    InertiaMatrix[1,1]=res22
+    InertiaMatrix[2,2]=res33
+    InertiaMatrix[0,1]=res12
+    InertiaMatrix[0,2]=res13
+    InertiaMatrix[1,2]=res23
+    InertiaMatrix[1,0]=res12
+    InertiaMatrix[2,0]=res13
+    InertiaMatrix[2,1]=res23
+    
+    return InertiaMatrix
+    
+        
+
+
+def CalculatePrincipalMomentofInertia(mol,ChargeCoordinates):
+    """
+    #################################################################
+    X,Y and Z-principal geometric moment.   
+    drived from ADAPT developed by Jurs.
+    #################################################################
+    """
+    InertiaMatrix=GetInertiaMatrix(mol,ChargeCoordinates)
+    ma=scipy.mean(InertiaMatrix,axis=1)
+    ms=scipy.std(InertiaMatrix,axis=1,ddof=1)
+    bb=scipy.ones((3,1))
+    InertiaMatrix=(InertiaMatrix-bb*ma.T)/(bb*ms.T)  
+    u,s,v=scipy.linalg.svd(InertiaMatrix)
+
+    res={}
+    res['IA']=round(s[2],3)
+    res['IB']=round(s[1],3)
+    res['IC']=round(s[0],3)
+    
+    return res
+    
+        
+def CalculateRatioPMI(mol,ChargeCoordinates):
+    """
+    #################################################################
+    The ratio of X/Y, Y/Z and X/Z (principal moment of inertia)
+    drived from ADAPT developed by Jurs.
+    #################################################################
+    """
+    temp=CalculatePrincipalMomentofInertia(mol,ChargeCoordinates)
+    res={}
+        
+    res['IA/B']=round(temp['IA']/temp['IB'],3)
+    res['IA/C']=round(temp['IA']/temp['IC'],3)
+    res['IB/C']=round(temp['IB']/temp['IC'],3)
+    return res
+
+
+
+
+
+
+def CalculateHarary3D(ChargeCoordinates):
+    """
+    #################################################################
+    The 3D-Harary index (H3D) is calculated as 
+    the sum of all the reciprocal geometric distances 
+    in a molecule. 
+    --->Harary3D
+    #################################################################
+    """
+    temp=[]
+    for i in ChargeCoordinates:       
+        temp.append([float(i[1]),float(i[2]),float(i[3])])    
+    DistanceMatrix=GetGementricalDistanceMatrix(temp) 
+    nAT=len(temp)
+    res=0.0
+    for i in range(nAT-1):
+        for j in range(i+1,nAT):
+            if DistanceMatrix[i,j]==0:
+                cds=0.0
+            else:
+                cds=1./DistanceMatrix[i,j]
+            res=res+cds
+    return round(res,3)
+            
+            
+
+
+def CalculateAverageGeometricalDistanceDegree(ChargeCoordinates):
+    """
+    #################################################################
+    The average geometric distance degree (AGDD) is 
+    calculated dividing the sum of all geometric distance 
+    degrees by the total number of molecule atoms (nAT). 
+    ---->AGDD
+    #################################################################
+    """
+    temp=[]
+    for i in ChargeCoordinates:       
+        temp.append([float(i[1]),float(i[2]),float(i[3])])    
+    DistanceMatrix=GetGementricalDistanceMatrix(temp) 
+    nAT=len(temp)
+    
+    res=sum(sum(DistanceMatrix))/nAT
+    
+    return round(res,3)
+    
+
+
+def CalculateAbsEigenvalueSumOnGeometricMatrix(ChargeCoordinates):
+    """
+    #################################################################
+    The absolute eigenvalue sum on geometry matrix (SEig) 
+    is the sum of the absolute eigenvalues of the geometry matrix. 
+    --->SEig
+    #################################################################
+    """
+    temp=[]
+    for i in ChargeCoordinates:       
+        temp.append([float(i[1]),float(i[2]),float(i[3])])    
+    DistanceMatrix=GetGementricalDistanceMatrix(temp) 
+    
+    u,s,vt=scipy.linalg.svd(DistanceMatrix)
+    
+    return round(sum(abs(s)),3)
+
+
+def CalculateSPANR(mol,ChargeCoordinates):
+    """
+    #################################################################
+    The span R (SPAN) is a size descriptor defined as 
+    the radius of the smallest sphere, centred on the centre 
+    of mass, completely enclosing all atoms of a molecule 
+    [G.A. Arteca, Molecular Shape Descriptors in Reviews in 
+    Computational Chemistry - Vol. 9, K.B. Lipkowitz, D. Boyd (Eds.), 
+    VCH Publishers, New York (NY), pp. 191-253, 1991]
+    --->SPAN
+    #################################################################
+    """
+    mol.removeh()
+    mol.addh()
+    temp=[]  
+    for i,j in enumerate(ChargeCoordinates):        
+        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])   
+     
+    masscenter=_GetMassCenter(temp)  
+    
+    res=[]
+    for i in temp:
+        res.append(GetAtomDistance(i[1],masscenter)) 
+
+    return round(float(max(res)),3)
+
+
+def CalculateAverageSPANR(mol,ChargeCoordinates):
+    """
+    #################################################################
+    The average span R (SPAM) is the root square of 
+    the ratio of SPAN over the number of atoms.
+    --->ASPAN
+    #################################################################
+    """
+    mol.removeh()
+    mol.addh()
+    temp=[]  
+    for i,j in enumerate(ChargeCoordinates):        
+        temp.append([mol.atoms[i].atomicmass,[float(j[1]),float(j[2]),float(j[3])]])   
+    
+    nAT=len(temp)
+    masscenter=_GetMassCenter(temp)      
+    res=[]
+    for i in temp:
+        res.append(GetAtomDistance(i[1],masscenter)) 
+
+    return round(math.pow(float(max(res))/nAT,0.5),3)
+
+
+def CalculateMolecularEccentricity(mol,ChargeCoordinates):
+    """
+    #################################################################
+    The molecular eccentricity (MEcc) is a shape descriptor 
+    calculated from the eigenvalues l of the molecular inertia matrix 
+    [G.A. Arteca, Molecular Shape Descriptors in Reviews 
+    in Computational Chemistry - Vol. 9, K.B. Lipkowitz, D. Boyd (Eds.), 
+    VCH Publishers, New York (NY), pp. 191-253, 1991].
+    --->MEcc
+    #################################################################
+    """
+    InertiaMatrix=GetInertiaMatrix(mol,ChargeCoordinates)
+    u,s,v=scipy.linalg.svd(InertiaMatrix)
+    
+    res1=s[0]
+    res3=s[2]
+    
+    res=math.pow(res1*res1-res3*res3,1./2)/res1
+    return round(res,3)
+    
+
+
+
+#############################################################################    
+
+def GetGeometric(mol):
+    """
+    #################################################################
+    Wrapper for Geometrical descriptors
+    #################################################################
+    """
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename)
+    res={}
+    res['W3DH']=Calculate3DWienerWithH(ChargeCoordinates)
+    res['W3D']=Calculate3DWienerWithoutH(ChargeCoordinates)
+    res['Petitj3D']=CalculatePetitjean3DIndex(ChargeCoordinates)
+    res['GeDi']=CalculateGemetricalDiameter(ChargeCoordinates)
+    res['grav']=CalculateGravitational3D1(mol,ChargeCoordinates)
+    res['rygr']=CalculateRadiusofGyration(mol,ChargeCoordinates)
+    res['Harary3D']=CalculateHarary3D(ChargeCoordinates)
+    res['AGDD']=CalculateAverageGeometricalDistanceDegree(ChargeCoordinates)
+    res['SEig']=CalculateAbsEigenvalueSumOnGeometricMatrix(ChargeCoordinates)
+    res['SPAN']=CalculateSPANR(mol,ChargeCoordinates)
+    res['ASPAN']=CalculateAverageSPANR(mol,ChargeCoordinates)
+    res['MEcc']=CalculateMolecularEccentricity(mol,ChargeCoordinates)
+    #res.update(CalculatePrincipalMomentofInertia(mol,ChargeCoordinates))
+    #res.update(CalculateRatioPMI(mol,ChargeCoordinates))
+    
+    return res
+
+def _GetHTMLDoc():
+    """
+    #################################################################
+    Write HTML documentation for this module.
+    #################################################################
+    """
+    import pydoc
+    pydoc.writedoc('geometric')
+    
+#############################################################################
+if __name__=="__main__":
+    
+    
+    from .GeoOpt import GetARCFile
+    mol='C1C=CCCS1'
+    mol='ClC(Cl)(Cl)Cl'
+
+
+    inputmol=pybel.readstring('smi',mol)  
+    GetARCFile(inputmol)
+    result=GetGeometric(inputmol)
+    print(result)
+    print(len(result))
diff -Naur pychem-1.0/src/pychem/GeoOpt.py pychem-1.0.3/src/pychem/GeoOpt.py
--- pychem-1.0/src/pychem/GeoOpt.py	2012-11-13 23:45:03.000000000 -0800
+++ pychem-1.0.3/src/pychem/GeoOpt.py	2017-01-20 11:03:44.680668323 -0800
@@ -1,208 +1,208 @@
-"""
-This module is used for optimizing molecular structures and getting ARC file
- 
-based on pybel and MOPAC!
-
-Written by Dongsheng Cao
-
-Date:2011.3.23
-"""
-
-
-import pybel
-import vector3d
-
-import os
-import string
-
-
-Version=1.1
-################################################################################
-class Atom:
-    """
-    #################################################################
-    A atom class used for wrapping some properties of atoms.
-    
-    Note that Coordinates is the output of the function 
-    
-    (_ReadCoordinates).
-    #################################################################
-    """
-
-    def __init__(self,Coordinates):
-        
-        self.pos = vector3d.Vector3d()
-        self.radius=0.0
-        self.Coordinates=Coordinates
-        self.Element=''
-        
-        
-    def SetCoordinates(self):
-        
-        temp=self.Coordinates
-        self.pos.x=float(temp[1])
-        self.pos.y=float(temp[2])
-        self.pos.z=float(temp[3])
-
-    def GetCoordinates(self):
-        
-        self.SetCoordinates()
-        
-        return self.pos
-        
-    def SetElement(self):
-        
-        temp=self.Coordinates
-        
-        self.Element=temp[0]
-        
-    def GetElement(self):
-        
-        self.SetElement()
-        
-        return self.Element
-        
-    def SetRadius(self):
-        
-        radii={ 'H': 1.20,'N': 1.55,'Na': 2.27,'Cu': 1.40,'Cl': 1.75,'C': 1.70,
-        'O': 1.52,'I': 1.98,'P': 1.80,'B': 1.85,'Br': 1.85,'S': 1.80,'Se': 1.90,
-        'F': 1.47,'Fe': 1.80,'K': 2.75,'Mn': 1.73,'Mg': 1.73,'Zn': 1.39,'Hg': 1.8,
-        'Li': 1.8,'.': 1.8}
-        
-        temp=self.GetElement()
-        
-        if temp in radii.keys():
-            self.radius=radii[temp]
-        else: 
-            self.radius=radii['.']
-            
-    def GetRadius(self):
-        
-        self.SetRadius()
-        
-        return self.radius
-###########################################################################
-
-def GetAtomClassList(Coordinates):
-    """
-    #################################################################
-    Combine all atoms in a molecule into a list form.
-    
-    Note that Coordinates is the output of the function (_ReadCoordinates).
-    #################################################################
-    """
-    Atoms=[]
-    for i in Coordinates:
-        atom=Atom(i)
-        atom.SetCoordinates()
-        atom.SetElement()
-        atom.SetRadius()
-        Atoms.append(atom)
-    return Atoms
-    
-###########################################################################    
-
-def _ReadCoordinates(filename="temp"):
-    """
-    #################################################################
-    Read the coordinates and charge of each atom in molecule from .arc file.
-    #################################################################
-    """
-    res=[]
-    
-    f=file(filename,'r')
-    templine=f.readlines()
-    f.close()
-    
-    for line in range(len(templine)):
-        if templine[line][-7:-1]=="CHARGE":
-            k=line
-            break
-        
-    for i in templine[k+4:len(templine)-1]:
-        
-        temp=i.split()
-        ElementCoordinate=[string.strip(temp[0]),string.strip(temp[1]),
-                           string.strip(temp[3]),string.strip(temp[5]),
-                           string.strip(temp[10])]
-        res.append(ElementCoordinate)
-
-    return res
-
-#############################################################################
-
-
-def FormatConversion(inputmol):
-    """
-    #################################################################
-    Using Pybel to convert the smi/sdf formats to mop format!
-    #################################################################
-    """
-    #inputmol.removeh()
-    inputmol.addh()
-    inputmol.make3D(forcefield='mmff94',steps=50)    ##Gemetrical optimization
-    ##forcefields = ['uff', 'mmff94', 'ghemical']
-    #make3D(self, forcefield = "mmff94", steps = 50)
-    ##inputmol.localopt(forcefield='mmff94',steps=50)
-    outputmol=pybel.Outputfile('mop',"temp.dat",overwrite=True)
-    outputmol.write(inputmol)
-    outputmol.close()
-    f=file('temp.dat','r+')
-    f.write('AM1              ')
-    f.close()
-
-
-def RunMOPAC(filename):
-    """
-    #################################################################
-    Run the MOPAC using os.system
-    #################################################################
-    """
-    
-    itest=os.system("run_mopac7"+" "+filename)
-    #time.sleep(1)
-    return itest
-
-############################################################################ 
-def GetARCFile(inputmol):  
-    """
-    #################################################################
-    Get ARC file for each molecule
-    #################################################################
-    """
-    
-    FormatConversion(inputmol)
-    
-    itest=RunMOPAC('temp')
-
-    if not itest:
-        print itest,'\t', 'Finshed successfully!'
-    else:
-        print itest,'\t', 'Failed Finished........'
- 
-    os.remove('temp.dat')
-    os.remove('temp.log')
-    os.remove('temp.OUT')    
-    #os.remove('temp.arc')
-    oldpath=os.getcwd()+'/temp.arc'
-    newpath=os.getcwd()+'/temp'
-    os.rename(oldpath,newpath)
-    
-##############################################################################   
-if __name__=="__main__":
-    
-    mol='C1C=CCS1'
-    mol='SCCC(=O)N1[C@@H](CCC1)C(=O)OCC'
-    inputmol=pybel.readstring('smi',mol)  
-    GetARCFile(inputmol)
-    res=_ReadCoordinates('temp')
-    print res
-
-
-
-
-
-
-
-
-
+"""
+This module is used for optimizing molecular structures and getting ARC file
+ 
+based on pybel and MOPAC!
+
+Written by Dongsheng Cao
+
+Date:2011.3.23
+"""
+
+
+import pybel
+from . import vector3d
+
+import os
+import string
+
+
+Version=1.1
+################################################################################
+class Atom:
+    """
+    #################################################################
+    A atom class used for wrapping some properties of atoms.
+    
+    Note that Coordinates is the output of the function 
+    
+    (_ReadCoordinates).
+    #################################################################
+    """
+
+    def __init__(self,Coordinates):
+        
+        self.pos = vector3d.Vector3d()
+        self.radius=0.0
+        self.Coordinates=Coordinates
+        self.Element=''
+        
+        
+    def SetCoordinates(self):
+        
+        temp=self.Coordinates
+        self.pos.x=float(temp[1])
+        self.pos.y=float(temp[2])
+        self.pos.z=float(temp[3])
+
+    def GetCoordinates(self):
+        
+        self.SetCoordinates()
+        
+        return self.pos
+        
+    def SetElement(self):
+        
+        temp=self.Coordinates
+        
+        self.Element=temp[0]
+        
+    def GetElement(self):
+        
+        self.SetElement()
+        
+        return self.Element
+        
+    def SetRadius(self):
+        
+        radii={ 'H': 1.20,'N': 1.55,'Na': 2.27,'Cu': 1.40,'Cl': 1.75,'C': 1.70,
+        'O': 1.52,'I': 1.98,'P': 1.80,'B': 1.85,'Br': 1.85,'S': 1.80,'Se': 1.90,
+        'F': 1.47,'Fe': 1.80,'K': 2.75,'Mn': 1.73,'Mg': 1.73,'Zn': 1.39,'Hg': 1.8,
+        'Li': 1.8,'.': 1.8}
+        
+        temp=self.GetElement()
+        
+        if temp in radii.keys():
+            self.radius=radii[temp]
+        else: 
+            self.radius=radii['.']
+            
+    def GetRadius(self):
+        
+        self.SetRadius()
+        
+        return self.radius
+###########################################################################
+
+def GetAtomClassList(Coordinates):
+    """
+    #################################################################
+    Combine all atoms in a molecule into a list form.
+    
+    Note that Coordinates is the output of the function (_ReadCoordinates).
+    #################################################################
+    """
+    Atoms=[]
+    for i in Coordinates:
+        atom=Atom(i)
+        atom.SetCoordinates()
+        atom.SetElement()
+        atom.SetRadius()
+        Atoms.append(atom)
+    return Atoms
+    
+###########################################################################    
+
+def _ReadCoordinates(filename="temp"):
+    """
+    #################################################################
+    Read the coordinates and charge of each atom in molecule from .arc file.
+    #################################################################
+    """
+    res=[]
+    
+    f=file(filename,'r')
+    templine=f.readlines()
+    f.close()
+    
+    for line in range(len(templine)):
+        if templine[line][-7:-1]=="CHARGE":
+            k=line
+            break
+        
+    for i in templine[k+4:len(templine)-1]:
+        
+        temp=i.split()
+        ElementCoordinate=[string.strip(temp[0]),string.strip(temp[1]),
+                           string.strip(temp[3]),string.strip(temp[5]),
+                           string.strip(temp[10])]
+        res.append(ElementCoordinate)
+
+    return res
+
+#############################################################################
+
+
+def FormatConversion(inputmol):
+    """
+    #################################################################
+    Using Pybel to convert the smi/sdf formats to mop format!
+    #################################################################
+    """
+    #inputmol.removeh()
+    inputmol.addh()
+    inputmol.make3D(forcefield='mmff94',steps=50)    ##Gemetrical optimization
+    ##forcefields = ['uff', 'mmff94', 'ghemical']
+    #make3D(self, forcefield = "mmff94", steps = 50)
+    ##inputmol.localopt(forcefield='mmff94',steps=50)
+    outputmol=pybel.Outputfile('mop',"temp.dat",overwrite=True)
+    outputmol.write(inputmol)
+    outputmol.close()
+    f=file('temp.dat','r+')
+    f.write('AM1              ')
+    f.close()
+
+
+def RunMOPAC(filename):
+    """
+    #################################################################
+    Run the MOPAC using os.system
+    #################################################################
+    """
+    
+    itest=os.system("run_mopac7"+" "+filename)
+    #time.sleep(1)
+    return itest
+
+############################################################################ 
+def GetARCFile(inputmol):  
+    """
+    #################################################################
+    Get ARC file for each molecule
+    #################################################################
+    """
+    
+    FormatConversion(inputmol)
+    
+    itest=RunMOPAC('temp')
+
+    if not itest:
+        print(itest,'\t', 'Finshed successfully!')
+    else:
+        print(itest,'\t', 'Failed Finished........')
+ 
+    os.remove('temp.dat')
+    os.remove('temp.log')
+    os.remove('temp.OUT')    
+    #os.remove('temp.arc')
+    oldpath=os.getcwd()+'/temp.arc'
+    newpath=os.getcwd()+'/temp'
+    os.rename(oldpath,newpath)
+    
+##############################################################################   
+if __name__=="__main__":
+    
+    mol='C1C=CCS1'
+    mol='SCCC(=O)N1[C@@H](CCC1)C(=O)OCC'
+    inputmol=pybel.readstring('smi',mol)  
+    GetARCFile(inputmol)
+    res=_ReadCoordinates('temp')
+    print(res)
+
+
+
+
+
+
+
+
+
diff -Naur pychem-1.0/src/pychem/getmol.py pychem-1.0.3/src/pychem/getmol.py
--- pychem-1.0/src/pychem/getmol.py	2012-11-17 04:15:08.000000000 -0800
+++ pychem-1.0.3/src/pychem/getmol.py	2017-01-20 11:03:44.680668323 -0800
@@ -195,13 +195,13 @@
 
 if __name__=="__main__":
     
-    print "Downloading......"
+    print("Downloading......")
     temp=GetMolFromCAS(casid="50-12-4")
-    print temp
+    print(temp)
     temp=GetMolFromNCBI(cid="2244")
-    print temp
+    print(temp)
     temp=GetMolFromDrugbank(dbid="DB00133")
-    print temp
+    print(temp)
     temp=GetMolFromKegg(kid="D02176")
-    print temp
+    print(temp)
 
diff -Naur pychem-1.0/src/pychem/kappa.py pychem-1.0.3/src/pychem/kappa.py
--- pychem-1.0/src/pychem/kappa.py	2012-11-17 05:49:58.000000000 -0800
+++ pychem-1.0.3/src/pychem/kappa.py	2017-01-20 11:03:44.680668323 -0800
@@ -283,8 +283,8 @@
     smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
     for index, smi in enumerate(smis):
         m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',GetKappa(m)
-        print '\t',len(GetKappa(m))
+        print(index+1)
+        print(smi)      
+        print('\t',GetKappa(m))
+        print('\t',len(GetKappa(m)))
 
diff -Naur pychem-1.0/src/pychem/moe.py pychem-1.0.3/src/pychem/moe.py
--- pychem-1.0/src/pychem/moe.py	2012-11-16 23:24:34.000000000 -0800
+++ pychem-1.0.3/src/pychem/moe.py	2017-01-20 11:03:44.680668323 -0800
@@ -1,243 +1,243 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-This module mainly implements the calculation of MOE-type descriptors, which 
-
-include LabuteASA, TPSA, slogPVSA, MRVSA, PEOEVSA, EstateVSA and VSAEstate, 
-
-respectively (60).
-
-If you have any question about these indices please contact me via email.
-
-My email adress is orientalcds@gmail.com 
-
-Created on Tue May 24 10:29:47 2011
-
-@author: Dongsheng Cao
-##############################################################################
-"""
-
-from rdkit import Chem
-from rdkit.Chem import MolSurf as MOE 
-from rdkit.Chem.EState import EState_VSA as EVSA
-
-
-Version=1.0
-################################################################
-
-def CalculateLabuteASA(mol):
-    """
-    #################################################################
-    Calculation of Labute's Approximate Surface Area (ASA from MOE)
-    
-    Usage:
-        
-        result=CalculateLabuteASA(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################
-    """
-    res={}
-    temp=MOE.pyLabuteASA(mol,includeHs=1)
-    res['LabuteASA']=round(temp,3)
-    return res
-
-def CalculateTPSA(mol):
-    """
-    #################################################################
-    Calculation of topological polar surface area based on fragments.
-    
-    Implementation based on the Daylight contrib program tpsa.
-    
-    Usage:
-        
-        result=CalculateTPSA(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################
-    """
-    res={}
-    temp=MOE.TPSA(mol)
-    res['TPSA1']=round(temp,3)
-    return res
-
-def CalculateSLOGPVSA(mol,bins=None):
-    """
-    #################################################################
-    MOE-type descriptors using LogP contributions and surface 
-    
-    area contributions.
-    
-    logpBins=[-0.4,-0.2,0,0.1,0.15,0.2,0.25,0.3,0.4,0.5,0.6]
-    
-    You can specify your own bins to compute some descriptors.
-    
-    Usage:
-        
-        result=CalculateSLOGPVSA(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################   
-    """
-    temp=MOE.SlogP_VSA_(mol,bins,force=1)
-    res={}
-    for i,j in enumerate(temp):
-        res['slogPVSA'+str(i)]=round(j,3)
-    return res
-
-
-def CalculateSMRVSA(mol,bins=None):
-    """
-    #################################################################
-    MOE-type descriptors using MR contributions and surface 
-    
-    area contributions.
-    
-    mrBins=[1.29, 1.82, 2.24, 2.45, 2.75, 3.05, 3.63,3.8,4.0]
-    
-    You can specify your own bins to compute some descriptors.
-    
-    Usage:
-        
-        result=CalculateSMRVSA(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################
-    """
-    temp=MOE.SMR_VSA_(mol,bins,force=1)
-    res={}
-    for i,j in enumerate(temp):
-        res['MRVSA'+str(i)]=round(j,3)
-    return res
-
-
-def CalculatePEOEVSA(mol,bins=None):
-    
-    """
-    #################################################################
-    MOE-type descriptors using partial charges and surface 
-    
-    area contributions.
-    
-    chgBins=[-.3,-.25,-.20,-.15,-.10,-.05,0,.05,.10,.15,.20,.25,.30]
-    
-    You can specify your own bins to compute some descriptors
-    
-    Usage:
-        
-        result=CalculatePEOEVSA(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################
-    """
-    temp=MOE.PEOE_VSA_(mol,bins,force=1)
-    res={}
-    for i,j in enumerate(temp):
-        res['PEOEVSA'+str(i)]=round(j,3)
-    return res    
-
-
-def CalculateEstateVSA(mol,bins=None):
-    """
-    #################################################################
-    MOE-type descriptors using Estate indices and surface area 
-    
-    contributions.
-    
-    estateBins=[-0.390,0.290,0.717,1.165,1.540,1.807,2.05,4.69,9.17,15.0] 
-    
-    You can specify your own bins to compute some descriptors
-    
-    Usage:
-        
-        result=CalculateEstateVSA(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################
-    """
-    temp=EVSA.EState_VSA_(mol,bins,force=1)
-    res={}
-    for i,j in enumerate(temp):
-        res['EstateVSA'+str(i)]=round(j,3)
-    return res
-
-
-def CalculateVSAEstate(mol,bins=None):
-    """
-    #################################################################
-    MOE-type descriptors using Estate indices and surface 
-    
-    area contributions.
-    
-    vsaBins=[4.78,5.00,5.410,5.740,6.00,6.07,6.45,7.00,11.0] 
-    
-    You can specify your own bins to compute some descriptors
-    
-    Usage:
-        
-        result=CalculateVSAEstate(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################
-    """
-    temp=EVSA.VSA_EState_(mol,bins,force=1)
-    res={}
-    for i,j in enumerate(temp):
-        res['VSAEstate'+str(i)]=round(j,3)
-    return res
-    
-    
-    
-def GetMOE(mol):
-    """
-    #################################################################
-    The calculation of MOE-type descriptors (ALL).
-    
-    Usage:
-        
-        result=GetMOE(mol)
-        
-        Input: mol is a molecule object
-        
-        Output: result is a dict form 
-    #################################################################
-    """
-    result={}
-    result.update(CalculateLabuteASA(mol))
-    result.update(CalculateTPSA(mol))
-    result.update(CalculateSLOGPVSA(mol,bins=None))
-    result.update(CalculateSMRVSA(mol,bins=None))
-    result.update(CalculatePEOEVSA(mol,bins=None))
-    result.update(CalculateEstateVSA(mol,bins=None))
-    result.update(CalculateVSAEstate(mol,bins=None))
-    return result
-
-#########################################################################
-
-if __name__=="__main__":
-    
-    
-    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    for index, smi in enumerate(smis):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',GetMOE(m)
-        print '\t', len(GetMOE(m))
-        
-
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+This module mainly implements the calculation of MOE-type descriptors, which 
+
+include LabuteASA, TPSA, slogPVSA, MRVSA, PEOEVSA, EstateVSA and VSAEstate, 
+
+respectively (60).
+
+If you have any question about these indices please contact me via email.
+
+My email adress is orientalcds@gmail.com 
+
+Created on Tue May 24 10:29:47 2011
+
+@author: Dongsheng Cao
+##############################################################################
+"""
+
+from rdkit import Chem
+from rdkit.Chem import MolSurf as MOE 
+from rdkit.Chem.EState import EState_VSA as EVSA
+
+
+Version=1.0
+################################################################
+
+def CalculateLabuteASA(mol):
+    """
+    #################################################################
+    Calculation of Labute's Approximate Surface Area (ASA from MOE)
+    
+    Usage:
+        
+        result=CalculateLabuteASA(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################
+    """
+    res={}
+    temp=MOE.pyLabuteASA(mol,includeHs=1)
+    res['LabuteASA']=round(temp,3)
+    return res
+
+def CalculateTPSA(mol):
+    """
+    #################################################################
+    Calculation of topological polar surface area based on fragments.
+    
+    Implementation based on the Daylight contrib program tpsa.
+    
+    Usage:
+        
+        result=CalculateTPSA(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################
+    """
+    res={}
+    temp=MOE.TPSA(mol)
+    res['TPSA1']=round(temp,3)
+    return res
+
+def CalculateSLOGPVSA(mol,bins=None):
+    """
+    #################################################################
+    MOE-type descriptors using LogP contributions and surface 
+    
+    area contributions.
+    
+    logpBins=[-0.4,-0.2,0,0.1,0.15,0.2,0.25,0.3,0.4,0.5,0.6]
+    
+    You can specify your own bins to compute some descriptors.
+    
+    Usage:
+        
+        result=CalculateSLOGPVSA(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################   
+    """
+    temp=MOE.SlogP_VSA_(mol,bins,force=1)
+    res={}
+    for i,j in enumerate(temp):
+        res['slogPVSA'+str(i)]=round(j,3)
+    return res
+
+
+def CalculateSMRVSA(mol,bins=None):
+    """
+    #################################################################
+    MOE-type descriptors using MR contributions and surface 
+    
+    area contributions.
+    
+    mrBins=[1.29, 1.82, 2.24, 2.45, 2.75, 3.05, 3.63,3.8,4.0]
+    
+    You can specify your own bins to compute some descriptors.
+    
+    Usage:
+        
+        result=CalculateSMRVSA(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################
+    """
+    temp=MOE.SMR_VSA_(mol,bins,force=1)
+    res={}
+    for i,j in enumerate(temp):
+        res['MRVSA'+str(i)]=round(j,3)
+    return res
+
+
+def CalculatePEOEVSA(mol,bins=None):
+    
+    """
+    #################################################################
+    MOE-type descriptors using partial charges and surface 
+    
+    area contributions.
+    
+    chgBins=[-.3,-.25,-.20,-.15,-.10,-.05,0,.05,.10,.15,.20,.25,.30]
+    
+    You can specify your own bins to compute some descriptors
+    
+    Usage:
+        
+        result=CalculatePEOEVSA(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################
+    """
+    temp=MOE.PEOE_VSA_(mol,bins,force=1)
+    res={}
+    for i,j in enumerate(temp):
+        res['PEOEVSA'+str(i)]=round(j,3)
+    return res    
+
+
+def CalculateEstateVSA(mol,bins=None):
+    """
+    #################################################################
+    MOE-type descriptors using Estate indices and surface area 
+    
+    contributions.
+    
+    estateBins=[-0.390,0.290,0.717,1.165,1.540,1.807,2.05,4.69,9.17,15.0] 
+    
+    You can specify your own bins to compute some descriptors
+    
+    Usage:
+        
+        result=CalculateEstateVSA(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################
+    """
+    temp=EVSA.EState_VSA_(mol,bins,force=1)
+    res={}
+    for i,j in enumerate(temp):
+        res['EstateVSA'+str(i)]=round(j,3)
+    return res
+
+
+def CalculateVSAEstate(mol,bins=None):
+    """
+    #################################################################
+    MOE-type descriptors using Estate indices and surface 
+    
+    area contributions.
+    
+    vsaBins=[4.78,5.00,5.410,5.740,6.00,6.07,6.45,7.00,11.0] 
+    
+    You can specify your own bins to compute some descriptors
+    
+    Usage:
+        
+        result=CalculateVSAEstate(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################
+    """
+    temp=EVSA.VSA_EState_(mol,bins,force=1)
+    res={}
+    for i,j in enumerate(temp):
+        res['VSAEstate'+str(i)]=round(j,3)
+    return res
+    
+    
+    
+def GetMOE(mol):
+    """
+    #################################################################
+    The calculation of MOE-type descriptors (ALL).
+    
+    Usage:
+        
+        result=GetMOE(mol)
+        
+        Input: mol is a molecule object
+        
+        Output: result is a dict form 
+    #################################################################
+    """
+    result={}
+    result.update(CalculateLabuteASA(mol))
+    result.update(CalculateTPSA(mol))
+    result.update(CalculateSLOGPVSA(mol,bins=None))
+    result.update(CalculateSMRVSA(mol,bins=None))
+    result.update(CalculatePEOEVSA(mol,bins=None))
+    result.update(CalculateEstateVSA(mol,bins=None))
+    result.update(CalculateVSAEstate(mol,bins=None))
+    return result
+
+#########################################################################
+
+if __name__=="__main__":
+    
+    
+    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    for index, smi in enumerate(smis):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+        print('\t',GetMOE(m))
+        print('\t', len(GetMOE(m)))
+        
+
diff -Naur pychem-1.0/src/pychem/molproperty.py pychem-1.0.3/src/pychem/molproperty.py
--- pychem-1.0/src/pychem/molproperty.py	2012-11-16 23:23:20.000000000 -0800
+++ pychem-1.0.3/src/pychem/molproperty.py	2017-01-20 11:03:44.680668323 -0800
@@ -1,273 +1,273 @@
-"""
-##############################################################################
-Calculation of Molecular physical/chemical properties based on some special 
-
-type of approaches(6), including: LogP; LogP2; MR; TPSA, UI and Hy.You can 
-
-freely use and distribute it. If you hava  any problem, you could contact 
-
-with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.09.18
-
-Email: oriental-cds@163.com
-##############################################################################
-"""
-from rdkit import Chem
-from rdkit.Chem import Crippen
-from rdkit.Chem import MolSurf as MS
-
-import math
-
-
-Version=1.0
-##############################################################
-def CalculateMolLogP(mol):
-    """
-    #################################################################
-    Cacluation of LogP value based on Crippen method
-    
-    ---->LogP
-    
-    Usage:
-        
-        result=CalculateMolLogP(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return round(Crippen._pyMolLogP(mol),3)
-
-def CalculateMolLogP2(mol):
-    """
-    #################################################################
-    Cacluation of LogP^2 value based on Crippen method
-    
-    ---->LogP2
-    
-    Usage:
-        
-        result=CalculateMolLogP2(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    res=Crippen._pyMolLogP(mol)
-    
-    return round(res**2,3)
-
-def CalculateMolMR(mol):
-    """
-    #################################################################
-    Cacluation of molecular refraction value based on Crippen method
-    
-    ---->MR
-    
-    Usage:
-        
-        result=CalculateMolMR(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return round(Crippen._pyMolMR(mol),3)
-
-def CalculateTPSA(mol):
-    """
-    #################################################################
-    calculates the polar surface area of a molecule based upon fragments
-
-    Algorithm in:
-        
-    P. Ertl, B. Rohde, P. Selzer
-    
-    Fast Calculation of Molecular Polar Surface Area as a Sum of 
-     
-    Fragment-based Contributions and Its Application to the Prediction
-     
-    of Drug Transport Properties, J.Med.Chem. 43, 3714-3717, 2000
-
-    Implementation based on the Daylight contrib program tpsa.
-    
-    ---->TPSA
-    
-    Usage:
-        
-        result=CalculateTPSA(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    return round(MS.TPSA(mol),3)
-
-
-def _CalculateBondNumber(mol,bondtype='SINGLE'):
-
-    """
-    ################################################################# 
-    **Internal used only*
-    
-    Calculation of bond counts in a molecule. it may be 
-    
-    SINGLE, DOUBLE, TRIPLE and AROMATIC
-    #################################################################
-    """
-    i=0;
-    for bond in mol.GetBonds():
-
-        if bond.GetBondType().name==bondtype:
-            i=i+1
-            
-    return i
-
-
-def CalculateUnsaturationIndex(mol):
-    """
-    #################################################################
-    Calculation of unsaturation index.
-    
-    ---->UI
-    
-    Usage:
-        
-        result=CalculateUnsaturationIndex(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    nd=_CalculateBondNumber(mol,bondtype='DOUBLE')
-    nt=_CalculateBondNumber(mol,bondtype='TRIPLE')
-    na=_CalculateBondNumber(mol,bondtype='AROMATIC')
-    res=math.log((1+nd+nt+na),2)
-    
-    return round(res,3)
-    
-
-def CalculateHydrophilicityFactor(mol):
-    """
-    #################################################################
-    Calculation of hydrophilicity factor. The hydrophilicity 
-    
-    index is described in more detail on page 225 of the 
-    
-    Handbook of Molecular Descriptors (Todeschini and Consonni 2000).
-    
-    ---->Hy
-    
-    Usage:
-        
-        result=CalculateHydrophilicityFactor(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    nheavy=mol.GetNumAtoms(onlyHeavy=1)
-    nc=0
-    for atom in mol.GetAtoms():
-        if atom.GetAtomicNum()==6:
-            nc=nc+1
-    nhy=0
-    for atom in mol.GetAtoms():
-        if atom.GetAtomicNum()==7 or atom.GetAtomicNum()==8 or atom.GetAtomicNum()==16:
-            atomn=atom.GetNeighbors()
-            for i in atomn:
-                if i.GetAtomicNum()==1:
-                    nhy=nhy+1
-                
-    res=(1+nhy)*math.log((1+nhy),2)+nc*(1.0/nheavy*math.log(1.0/nheavy,2))+math.sqrt((nhy+0.0)/(nheavy^2))
-    return round(res,3)
-    
-
-def CalculateXlogP(mol):
-    """
-    #################################################################
-    Calculation of Wang octanol water partition coefficient.
-    
-    ---->XLogP
-    
-    Usage:
-        
-        result=CalculateXlogP(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    pass
-
-
-def CalculateXlogP2(mol):
-    """
-    #################################################################
-    Calculation of Wang octanol water partition coefficient (XLogP^2).
-    
-    ---->XLogP2
-    
-    Usage:
-        
-        result=CalculateMolLogP(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a numeric value.
-    #################################################################
-    """
-    pass
-
-
-MolecularProperty={'LogP':CalculateMolLogP,
-                   'LogP2':CalculateMolLogP2,
-                   'MR':CalculateMolMR,
-                   'TPSA':CalculateTPSA,
-                   'Hy':CalculateHydrophilicityFactor,
-                   'UI':CalculateUnsaturationIndex
-    }
-
-def GetMolecularProperty(mol):
-    """
-    #################################################################
-    Get the dictionary of constitutional descriptors for 
-    
-    given moelcule mol
-    
-    Usage:
-        
-        result=GetMolecularProperty(mol)
-        
-        Input: mol is a molecule object.
-        
-        Output: result is a dict form containing 6 molecular properties.
-    #################################################################
-    """
-    result={}
-    for DesLabel in MolecularProperty.keys():
-        result[DesLabel]=MolecularProperty[DesLabel](mol)
-    return result
-    
-##########################################################
-
-if __name__ =='__main__':
-
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    smi5=['CCCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N']
-    for index, smi in enumerate(smis):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',GetMolecularProperty(m)
-    #f.close()
+"""
+##############################################################################
+Calculation of Molecular physical/chemical properties based on some special 
+
+type of approaches(6), including: LogP; LogP2; MR; TPSA, UI and Hy.You can 
+
+freely use and distribute it. If you hava  any problem, you could contact 
+
+with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.09.18
+
+Email: oriental-cds@163.com
+##############################################################################
+"""
+from rdkit import Chem
+from rdkit.Chem import Crippen
+from rdkit.Chem import MolSurf as MS
+
+import math
+
+
+Version=1.0
+##############################################################
+def CalculateMolLogP(mol):
+    """
+    #################################################################
+    Cacluation of LogP value based on Crippen method
+    
+    ---->LogP
+    
+    Usage:
+        
+        result=CalculateMolLogP(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return round(Crippen._pyMolLogP(mol),3)
+
+def CalculateMolLogP2(mol):
+    """
+    #################################################################
+    Cacluation of LogP^2 value based on Crippen method
+    
+    ---->LogP2
+    
+    Usage:
+        
+        result=CalculateMolLogP2(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    res=Crippen._pyMolLogP(mol)
+    
+    return round(res**2,3)
+
+def CalculateMolMR(mol):
+    """
+    #################################################################
+    Cacluation of molecular refraction value based on Crippen method
+    
+    ---->MR
+    
+    Usage:
+        
+        result=CalculateMolMR(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return round(Crippen._pyMolMR(mol),3)
+
+def CalculateTPSA(mol):
+    """
+    #################################################################
+    calculates the polar surface area of a molecule based upon fragments
+
+    Algorithm in:
+        
+    P. Ertl, B. Rohde, P. Selzer
+    
+    Fast Calculation of Molecular Polar Surface Area as a Sum of 
+     
+    Fragment-based Contributions and Its Application to the Prediction
+     
+    of Drug Transport Properties, J.Med.Chem. 43, 3714-3717, 2000
+
+    Implementation based on the Daylight contrib program tpsa.
+    
+    ---->TPSA
+    
+    Usage:
+        
+        result=CalculateTPSA(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    return round(MS.TPSA(mol),3)
+
+
+def _CalculateBondNumber(mol,bondtype='SINGLE'):
+
+    """
+    ################################################################# 
+    **Internal used only*
+    
+    Calculation of bond counts in a molecule. it may be 
+    
+    SINGLE, DOUBLE, TRIPLE and AROMATIC
+    #################################################################
+    """
+    i=0;
+    for bond in mol.GetBonds():
+
+        if bond.GetBondType().name==bondtype:
+            i=i+1
+            
+    return i
+
+
+def CalculateUnsaturationIndex(mol):
+    """
+    #################################################################
+    Calculation of unsaturation index.
+    
+    ---->UI
+    
+    Usage:
+        
+        result=CalculateUnsaturationIndex(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    nd=_CalculateBondNumber(mol,bondtype='DOUBLE')
+    nt=_CalculateBondNumber(mol,bondtype='TRIPLE')
+    na=_CalculateBondNumber(mol,bondtype='AROMATIC')
+    res=math.log((1+nd+nt+na),2)
+    
+    return round(res,3)
+    
+
+def CalculateHydrophilicityFactor(mol):
+    """
+    #################################################################
+    Calculation of hydrophilicity factor. The hydrophilicity 
+    
+    index is described in more detail on page 225 of the 
+    
+    Handbook of Molecular Descriptors (Todeschini and Consonni 2000).
+    
+    ---->Hy
+    
+    Usage:
+        
+        result=CalculateHydrophilicityFactor(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    nheavy=mol.GetNumAtoms(onlyHeavy=1)
+    nc=0
+    for atom in mol.GetAtoms():
+        if atom.GetAtomicNum()==6:
+            nc=nc+1
+    nhy=0
+    for atom in mol.GetAtoms():
+        if atom.GetAtomicNum()==7 or atom.GetAtomicNum()==8 or atom.GetAtomicNum()==16:
+            atomn=atom.GetNeighbors()
+            for i in atomn:
+                if i.GetAtomicNum()==1:
+                    nhy=nhy+1
+                
+    res=(1+nhy)*math.log((1+nhy),2)+nc*(1.0/nheavy*math.log(1.0/nheavy,2))+math.sqrt((nhy+0.0)/(nheavy^2))
+    return round(res,3)
+    
+
+def CalculateXlogP(mol):
+    """
+    #################################################################
+    Calculation of Wang octanol water partition coefficient.
+    
+    ---->XLogP
+    
+    Usage:
+        
+        result=CalculateXlogP(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    pass
+
+
+def CalculateXlogP2(mol):
+    """
+    #################################################################
+    Calculation of Wang octanol water partition coefficient (XLogP^2).
+    
+    ---->XLogP2
+    
+    Usage:
+        
+        result=CalculateMolLogP(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a numeric value.
+    #################################################################
+    """
+    pass
+
+
+MolecularProperty={'LogP':CalculateMolLogP,
+                   'LogP2':CalculateMolLogP2,
+                   'MR':CalculateMolMR,
+                   'TPSA':CalculateTPSA,
+                   'Hy':CalculateHydrophilicityFactor,
+                   'UI':CalculateUnsaturationIndex
+    }
+
+def GetMolecularProperty(mol):
+    """
+    #################################################################
+    Get the dictionary of constitutional descriptors for 
+    
+    given moelcule mol
+    
+    Usage:
+        
+        result=GetMolecularProperty(mol)
+        
+        Input: mol is a molecule object.
+        
+        Output: result is a dict form containing 6 molecular properties.
+    #################################################################
+    """
+    result={}
+    for DesLabel in MolecularProperty.keys():
+        result[DesLabel]=MolecularProperty[DesLabel](mol)
+    return result
+    
+##########################################################
+
+if __name__ =='__main__':
+
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    smi5=['CCCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCCCCN','c1ccccc1N']
+    for index, smi in enumerate(smis):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+        print('\t',GetMolecularProperty(m))
+    #f.close()
diff -Naur pychem-1.0/src/pychem/moran.py pychem-1.0.3/src/pychem/moran.py
--- pychem-1.0/src/pychem/moran.py	2012-09-19 06:04:05.000000000 -0700
+++ pychem-1.0.3/src/pychem/moran.py	2017-01-20 11:03:44.680668323 -0800
@@ -1,237 +1,237 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-
-The calculation of Moran autocorrelation descriptors. You can get 32 molecular
-
-decriptors. You can freely use and distribute it. If you hava  any problem, 
-
-you could contact with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.09.18
-
-Email: oriental-cds@163.com
-
-##############################################################################
-"""
-
-from rdkit import Chem
-from AtomProperty import GetRelativeAtomicProperty
-
-import numpy
-
-
-Version=1.0
-################################################################
-
-def _CalculateMoranAutocorrelation(mol,lag=1,propertylabel='m'):
-    """
-    #################################################################
-    **Internal used only**
-    
-    Calculation of Moran autocorrelation descriptors based on 
-    
-    different property weights.
-    
-    Usage:
-        
-    res=_CalculateMoranAutocorrelation(mol,lag=1,propertylabel='m')
-    
-    Input: mol is a molecule object.
-    
-    lag is the topological distance between atom i and atom j.
-    
-    propertylabel is the weighted property.
-    
-    Output: res is a numeric value.
-    #################################################################  
-    """
-
-    Natom=mol.GetNumAtoms()
-    
-    prolist=[]
-    for i in mol.GetAtoms():
-        temp=GetRelativeAtomicProperty(i.GetSymbol(),propertyname=propertylabel)
-        prolist.append(temp)
-        
-    aveweight=sum(prolist)/Natom
-    
-    tempp=[numpy.square(x-aveweight) for x in prolist]   
-    
-    GetDistanceMatrix=Chem.GetDistanceMatrix(mol)
-    res=0.0
-    index=0
-    for i in range(Natom):
-        for j in range(Natom):  
-            if GetDistanceMatrix[i,j]==lag:
-                atom1=mol.GetAtomWithIdx(i)
-                atom2=mol.GetAtomWithIdx(j)
-                temp1=GetRelativeAtomicProperty(element=atom1.GetSymbol(),propertyname=propertylabel)
-                temp2=GetRelativeAtomicProperty(element=atom2.GetSymbol(),propertyname=propertylabel)
-                res=res+(temp1-aveweight)*(temp2-aveweight)
-                index=index+1
-            else:
-                res=res+0.0
-                
-                
-    if sum(tempp)==0 or index==0:
-        result=0
-    else:
-        result=(res/index)/(sum(tempp)/Natom)
-                
-    return round(result,3)
-
-
-def CalculateMoranAutoMass(mol):
-    """
-    #################################################################
-    Calculation of Moran autocorrelation descriptors based on 
-    
-    carbon-scaled atomic mass.
-    
-    Usage:
-    
-    res=CalculateMoranAutoMass(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight moran autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['MATSm'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='m')
-    
-    
-    return res
-
-
-def CalculateMoranAutoVolume(mol):
-    """
-    #################################################################
-    Calculation of Moran autocorrelation descriptors based on 
-    
-    carbon-scaled atomic van der Waals volume.
-
-    Usage:
-    
-    res=CalculateMoranAutoVolume(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight moran autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['MATSv'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='V')
-    
-    
-    return res
-
-def CalculateMoranAutoElectronegativity(mol):
-    """
-    #################################################################
-    Calculation of Moran autocorrelation descriptors based on 
-    
-    carbon-scaled atomic Sanderson electronegativity.
-    
-    Usage:
-    
-    res=CalculateMoranAutoElectronegativity(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight moran autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['MATSe'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='En')
-    
-    
-    return res
-
-def CalculateMoranAutoPolarizability(mol):
-    """
-    #################################################################
-    Calculation of Moran autocorrelation descriptors based on 
-    
-    carbon-scaled atomic polarizability.
-    
-    Usage:
-    
-    res=CalculateMoranAutoPolarizability(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight moran autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['MATSp'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='alapha')
-    
-    
-    return res
-
-
-def GetMoranAuto(mol):
-    """
-    #################################################################
-    Calcualate all Moran autocorrelation descriptors.
-    
-    (carbon-scaled atomic mass, carbon-scaled atomic van der Waals volume,
-     
-    carbon-scaled atomic Sanderson electronegativity,
-     
-    carbon-scaled atomic polarizability)
-    
-    Usage:
-    
-    res=GetMoranAuto(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing all moran autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    res.update(CalculateMoranAutoMass(mol))
-    res.update(CalculateMoranAutoVolume(mol))
-    res.update(CalculateMoranAutoElectronegativity(mol))
-    res.update(CalculateMoranAutoPolarizability(mol))
-    
-    return res
-###########################################################################
-if __name__=='__main__':
-    
-
-    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    for index, smi in enumerate(smis):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-##        print '\t',CalculateEstateFingerprint(m)
-##        print '\t',CalculateEstateValue(m)
-##        print '\t',CalculateMaxAtomTypeEState(m)
-##        print '\t', CalculateMinAtomTypeEState(m)
-        
-        print GetMoranAuto(m)
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+
+The calculation of Moran autocorrelation descriptors. You can get 32 molecular
+
+decriptors. You can freely use and distribute it. If you hava  any problem, 
+
+you could contact with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.09.18
+
+Email: oriental-cds@163.com
+
+##############################################################################
+"""
+
+from rdkit import Chem
+from .AtomProperty import GetRelativeAtomicProperty
+
+import numpy
+
+
+Version=1.0
+################################################################
+
+def _CalculateMoranAutocorrelation(mol,lag=1,propertylabel='m'):
+    """
+    #################################################################
+    **Internal used only**
+    
+    Calculation of Moran autocorrelation descriptors based on 
+    
+    different property weights.
+    
+    Usage:
+        
+    res=_CalculateMoranAutocorrelation(mol,lag=1,propertylabel='m')
+    
+    Input: mol is a molecule object.
+    
+    lag is the topological distance between atom i and atom j.
+    
+    propertylabel is the weighted property.
+    
+    Output: res is a numeric value.
+    #################################################################  
+    """
+
+    Natom=mol.GetNumAtoms()
+    
+    prolist=[]
+    for i in mol.GetAtoms():
+        temp=GetRelativeAtomicProperty(i.GetSymbol(),propertyname=propertylabel)
+        prolist.append(temp)
+        
+    aveweight=sum(prolist)/Natom
+    
+    tempp=[numpy.square(x-aveweight) for x in prolist]   
+    
+    GetDistanceMatrix=Chem.GetDistanceMatrix(mol)
+    res=0.0
+    index=0
+    for i in range(Natom):
+        for j in range(Natom):  
+            if GetDistanceMatrix[i,j]==lag:
+                atom1=mol.GetAtomWithIdx(i)
+                atom2=mol.GetAtomWithIdx(j)
+                temp1=GetRelativeAtomicProperty(element=atom1.GetSymbol(),propertyname=propertylabel)
+                temp2=GetRelativeAtomicProperty(element=atom2.GetSymbol(),propertyname=propertylabel)
+                res=res+(temp1-aveweight)*(temp2-aveweight)
+                index=index+1
+            else:
+                res=res+0.0
+                
+                
+    if sum(tempp)==0 or index==0:
+        result=0
+    else:
+        result=(res/index)/(sum(tempp)/Natom)
+                
+    return round(result,3)
+
+
+def CalculateMoranAutoMass(mol):
+    """
+    #################################################################
+    Calculation of Moran autocorrelation descriptors based on 
+    
+    carbon-scaled atomic mass.
+    
+    Usage:
+    
+    res=CalculateMoranAutoMass(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight moran autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['MATSm'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='m')
+    
+    
+    return res
+
+
+def CalculateMoranAutoVolume(mol):
+    """
+    #################################################################
+    Calculation of Moran autocorrelation descriptors based on 
+    
+    carbon-scaled atomic van der Waals volume.
+
+    Usage:
+    
+    res=CalculateMoranAutoVolume(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight moran autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['MATSv'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='V')
+    
+    
+    return res
+
+def CalculateMoranAutoElectronegativity(mol):
+    """
+    #################################################################
+    Calculation of Moran autocorrelation descriptors based on 
+    
+    carbon-scaled atomic Sanderson electronegativity.
+    
+    Usage:
+    
+    res=CalculateMoranAutoElectronegativity(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight moran autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['MATSe'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='En')
+    
+    
+    return res
+
+def CalculateMoranAutoPolarizability(mol):
+    """
+    #################################################################
+    Calculation of Moran autocorrelation descriptors based on 
+    
+    carbon-scaled atomic polarizability.
+    
+    Usage:
+    
+    res=CalculateMoranAutoPolarizability(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight moran autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['MATSp'+str(i+1)]=_CalculateMoranAutocorrelation(mol,lag=i+1,propertylabel='alapha')
+    
+    
+    return res
+
+
+def GetMoranAuto(mol):
+    """
+    #################################################################
+    Calcualate all Moran autocorrelation descriptors.
+    
+    (carbon-scaled atomic mass, carbon-scaled atomic van der Waals volume,
+     
+    carbon-scaled atomic Sanderson electronegativity,
+     
+    carbon-scaled atomic polarizability)
+    
+    Usage:
+    
+    res=GetMoranAuto(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing all moran autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    res.update(CalculateMoranAutoMass(mol))
+    res.update(CalculateMoranAutoVolume(mol))
+    res.update(CalculateMoranAutoElectronegativity(mol))
+    res.update(CalculateMoranAutoPolarizability(mol))
+    
+    return res
+###########################################################################
+if __name__=='__main__':
+    
+
+    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    for index, smi in enumerate(smis):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+##        print '\t',CalculateEstateFingerprint(m)
+##        print '\t',CalculateEstateValue(m)
+##        print '\t',CalculateMaxAtomTypeEState(m)
+##        print '\t', CalculateMinAtomTypeEState(m)
+        
+        print(GetMoranAuto(m))
diff -Naur pychem-1.0/src/pychem/moreaubroto.py pychem-1.0.3/src/pychem/moreaubroto.py
--- pychem-1.0/src/pychem/moreaubroto.py	2012-11-09 08:21:17.000000000 -0800
+++ pychem-1.0.3/src/pychem/moreaubroto.py	2017-01-20 11:03:44.680668323 -0800
@@ -1,219 +1,219 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-
-The calculation of Moreau-Broto autocorrelation descriptors. You can get 32
-
-molecular decriptors. You can freely use and distribute it. If you hava  
-
-any problem, you could contact with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.09.18
-
-Email: oriental-cds@163.com
-
-##############################################################################
-"""
-
-
-from rdkit import Chem
-from AtomProperty import GetRelativeAtomicProperty
-
-import numpy
-
-
-Version=1.0
-################################################################
-
-def _CalculateMoreauBrotoAutocorrelation(mol,lag=1,propertylabel='m'):
-    """
-    #################################################################
-    **Internal used only**
-    
-    Calculation of Moreau-Broto autocorrelation descriptors based on 
-    
-    different property weights.
-    
-    Usage:
-    
-    res=_CalculateMoreauBrotoAutocorrelation(mol, lag=1,propertylabel='m')
-    
-    Input: mol is a molecule object.
-    
-    lag is the topological distance between atom i and atom j.
-    
-    propertylabel is the weighted property.
-    
-    Output: res is a numeric value.
-    #################################################################
-    """
-
-    Natom=mol.GetNumAtoms()
-    
-    GetDistanceMatrix=Chem.GetDistanceMatrix(mol)
-    res=0.0
-    for i in range(Natom):
-        for j in range(Natom):  
-            if GetDistanceMatrix[i,j]==lag:
-                atom1=mol.GetAtomWithIdx(i)
-                atom2=mol.GetAtomWithIdx(j)
-                temp1=GetRelativeAtomicProperty(element=atom1.GetSymbol(),propertyname=propertylabel)
-                temp2=GetRelativeAtomicProperty(element=atom2.GetSymbol(),propertyname=propertylabel)
-                res=res+temp1*temp2
-            else:
-                res=res+0.0
-                
-    return round(numpy.log(res/2+1),3)
-
-
-def CalculateMoreauBrotoAutoMass(mol):
-    """
-    #################################################################
-    Calculation of Moreau-Broto autocorrelation descriptors based on 
-    
-    carbon-scaled atomic mass.
-    
-    Usage:
-    
-    res=CalculateMoreauBrotoAutoMass(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing eight moreau broto autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['ATSm'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='m')
-    
-    
-    return res
-
-
-def CalculateMoreauBrotoAutoVolume(mol):
-    """
-    #################################################################
-    Calculation of Moreau-Broto autocorrelation descriptors based on 
-    
-    carbon-scaled atomic van der Waals volume.
-    
-    Usage: 
-    
-    res=CalculateMoreauBrotoAutoVolume(mol)
-    
-    Input: mol is a molcule object.
-    
-    Output: res is a dict form containing eight moreau broto autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['ATSv'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='V')
-    
-    
-    return res
-
-def CalculateMoreauBrotoAutoElectronegativity(mol):
-    """
-    #################################################################
-    Calculation of Moreau-Broto autocorrelation descriptors based on 
-    
-    carbon-scaled atomic Sanderson electronegativity.
-
-    Usage: 
-    
-    res=CalculateMoreauBrotoAutoElectronegativity(mol)
-    
-    Input: mol is a molcule object.
-    
-    Output: res is a dict form containing eight moreau broto autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['ATSe'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='En')
-    
-    
-    return res
-
-def CalculateMoreauBrotoAutoPolarizability(mol):
-    """
-    #################################################################
-    Calculation of Moreau-Broto autocorrelation descriptors based on 
-    
-    carbon-scaled atomic polarizability.
-
-    res=CalculateMoreauBrotoAutoPolarizability(mol)
-    
-    Input: mol is a molcule object.
-    
-    Output: res is a dict form containing eight moreau broto autocorrealtion
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    
-    for i in range(8):
-        res['ATSp'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='alapha')
-    
-    
-    return res
-
-
-def GetMoreauBrotoAuto(mol):
-    """
-    #################################################################
-    Calcualate all Moreau-Broto autocorrelation descriptors. 
-    
-    (carbon-scaled atomic mass, carbon-scaled atomic van der Waals volume,
-     
-    carbon-scaled atomic Sanderson electronegativity,
-     
-    carbon-scaled atomic polarizability)
-    
-    Usage:
-    
-    res=GetMoreauBrotoAuto(mol)
-    
-    Input: mol is a molecule object.
-    
-    Output: res is a dict form containing all moreau broto autocorrelation
-    
-    descriptors.
-    #################################################################
-    """
-    res={}
-    res.update(CalculateMoreauBrotoAutoMass(mol))
-    res.update(CalculateMoreauBrotoAutoVolume(mol))
-    res.update(CalculateMoreauBrotoAutoElectronegativity(mol))
-    res.update(CalculateMoreauBrotoAutoPolarizability(mol))
-    
-    return res
-###########################################################################
-if __name__=='__main__':
-    
-   
-    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
-    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
-    for index, smi in enumerate(smis):
-        m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-##        print '\t',CalculateEstateFingerprint(m)
-##        print '\t',CalculateEstateValue(m)
-##        print '\t',CalculateMaxAtomTypeEState(m)
-##        print '\t', CalculateMinAtomTypeEState(m)
-        
-        print len(GetMoreauBrotoAuto(m))
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+
+The calculation of Moreau-Broto autocorrelation descriptors. You can get 32
+
+molecular decriptors. You can freely use and distribute it. If you hava  
+
+any problem, you could contact with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.09.18
+
+Email: oriental-cds@163.com
+
+##############################################################################
+"""
+
+
+from rdkit import Chem
+from .AtomProperty import GetRelativeAtomicProperty
+
+import numpy
+
+
+Version=1.0
+################################################################
+
+def _CalculateMoreauBrotoAutocorrelation(mol,lag=1,propertylabel='m'):
+    """
+    #################################################################
+    **Internal used only**
+    
+    Calculation of Moreau-Broto autocorrelation descriptors based on 
+    
+    different property weights.
+    
+    Usage:
+    
+    res=_CalculateMoreauBrotoAutocorrelation(mol, lag=1,propertylabel='m')
+    
+    Input: mol is a molecule object.
+    
+    lag is the topological distance between atom i and atom j.
+    
+    propertylabel is the weighted property.
+    
+    Output: res is a numeric value.
+    #################################################################
+    """
+
+    Natom=mol.GetNumAtoms()
+    
+    GetDistanceMatrix=Chem.GetDistanceMatrix(mol)
+    res=0.0
+    for i in range(Natom):
+        for j in range(Natom):  
+            if GetDistanceMatrix[i,j]==lag:
+                atom1=mol.GetAtomWithIdx(i)
+                atom2=mol.GetAtomWithIdx(j)
+                temp1=GetRelativeAtomicProperty(element=atom1.GetSymbol(),propertyname=propertylabel)
+                temp2=GetRelativeAtomicProperty(element=atom2.GetSymbol(),propertyname=propertylabel)
+                res=res+temp1*temp2
+            else:
+                res=res+0.0
+                
+    return round(numpy.log(res/2+1),3)
+
+
+def CalculateMoreauBrotoAutoMass(mol):
+    """
+    #################################################################
+    Calculation of Moreau-Broto autocorrelation descriptors based on 
+    
+    carbon-scaled atomic mass.
+    
+    Usage:
+    
+    res=CalculateMoreauBrotoAutoMass(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing eight moreau broto autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['ATSm'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='m')
+    
+    
+    return res
+
+
+def CalculateMoreauBrotoAutoVolume(mol):
+    """
+    #################################################################
+    Calculation of Moreau-Broto autocorrelation descriptors based on 
+    
+    carbon-scaled atomic van der Waals volume.
+    
+    Usage: 
+    
+    res=CalculateMoreauBrotoAutoVolume(mol)
+    
+    Input: mol is a molcule object.
+    
+    Output: res is a dict form containing eight moreau broto autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['ATSv'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='V')
+    
+    
+    return res
+
+def CalculateMoreauBrotoAutoElectronegativity(mol):
+    """
+    #################################################################
+    Calculation of Moreau-Broto autocorrelation descriptors based on 
+    
+    carbon-scaled atomic Sanderson electronegativity.
+
+    Usage: 
+    
+    res=CalculateMoreauBrotoAutoElectronegativity(mol)
+    
+    Input: mol is a molcule object.
+    
+    Output: res is a dict form containing eight moreau broto autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['ATSe'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='En')
+    
+    
+    return res
+
+def CalculateMoreauBrotoAutoPolarizability(mol):
+    """
+    #################################################################
+    Calculation of Moreau-Broto autocorrelation descriptors based on 
+    
+    carbon-scaled atomic polarizability.
+
+    res=CalculateMoreauBrotoAutoPolarizability(mol)
+    
+    Input: mol is a molcule object.
+    
+    Output: res is a dict form containing eight moreau broto autocorrealtion
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    
+    for i in range(8):
+        res['ATSp'+str(i+1)]=_CalculateMoreauBrotoAutocorrelation(mol,lag=i+1,propertylabel='alapha')
+    
+    
+    return res
+
+
+def GetMoreauBrotoAuto(mol):
+    """
+    #################################################################
+    Calcualate all Moreau-Broto autocorrelation descriptors. 
+    
+    (carbon-scaled atomic mass, carbon-scaled atomic van der Waals volume,
+     
+    carbon-scaled atomic Sanderson electronegativity,
+     
+    carbon-scaled atomic polarizability)
+    
+    Usage:
+    
+    res=GetMoreauBrotoAuto(mol)
+    
+    Input: mol is a molecule object.
+    
+    Output: res is a dict form containing all moreau broto autocorrelation
+    
+    descriptors.
+    #################################################################
+    """
+    res={}
+    res.update(CalculateMoreauBrotoAutoMass(mol))
+    res.update(CalculateMoreauBrotoAutoVolume(mol))
+    res.update(CalculateMoreauBrotoAutoElectronegativity(mol))
+    res.update(CalculateMoreauBrotoAutoPolarizability(mol))
+    
+    return res
+###########################################################################
+if __name__=='__main__':
+    
+   
+    smi5=['COCCCC','CCC(C)CC','CC(C)CCC','CC(C)C(C)C','CCOCCN','c1ccccc1N']
+    smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-].[Na+]']
+    for index, smi in enumerate(smis):
+        m = Chem.MolFromSmiles(smi)
+        print(index+1)
+        print(smi)      
+##        print '\t',CalculateEstateFingerprint(m)
+##        print '\t',CalculateEstateValue(m)
+##        print '\t',CalculateMaxAtomTypeEState(m)
+##        print '\t', CalculateMinAtomTypeEState(m)
+        
+        print(len(GetMoreauBrotoAuto(m)))
diff -Naur pychem-1.0/src/pychem/morse.py pychem-1.0.3/src/pychem/morse.py
--- pychem-1.0/src/pychem/morse.py	2012-11-14 05:49:18.000000000 -0800
+++ pychem-1.0.3/src/pychem/morse.py	2017-01-20 11:03:44.684668416 -0800
@@ -1,426 +1,426 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-
-The calculation of 3D morse descriptors. You can get 210 molecular
-
-decriptors. You can freely use and distribute it. If you hava  
-
-any problem, you could contact with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.11.13
-
-Email: oriental-cds@163.com
-
-##############################################################################
-"""
-
-from GeoOpt import _ReadCoordinates
-from AtomProperty import GetRelativeAtomicProperty
-
-import pybel
-import scipy
-
-import math
-
-
-Version=1.0
-###set the parameters in RDF equation
-_beta=100
-
-def _GetR(n=32):
-    """
-    #################################################################
-    *Internal Use Only*
-    
-    Obtain the parameter R in RDF equation.
-    #################################################################
-    """
-    R=[]
-    for i in range(1,n+1):
-        R.append(float(i*1))
-    return R
-
-
-def _GetAtomDistance(x,y):
-    """
-    #################################################################
-    *Internal Use Only*
-    
-    Obtain the Elucidian distance based on the coordinates of two atoms
-    #################################################################
-    """
-
-    temp=[math.pow(x[0]-y[0],2),math.pow(x[1]-y[1],2),math.pow(x[2]-y[2],2)]
-    res=math.sqrt(sum(temp))
-    return res
-    
-
-def _GetGementricalDistanceMatrix(CoordinateList):
-    """
-    #################################################################
-    *Internal Use Only*
-    
-    Obtain the distance matrix of a molecule based on coordinate list
-    #################################################################
-    """
-    NAtom=len(CoordinateList)
-    DistanceMatrix=scipy.zeros((NAtom,NAtom))
-    for i in range(NAtom-1):
-        for j in range(i+1,NAtom):
-            DistanceMatrix[i,j]=_GetAtomDistance(CoordinateList[i],CoordinateList[j])
-            DistanceMatrix[j,i]=DistanceMatrix[i,j]
-    return DistanceMatrix
-
-    
-def CalculateUnweightMoRSE(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  unweighted 3-D MoRse descriptors 
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-#    ChargeCoordinates=_ReadCoordinates('temp.arc')
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        
-    DM=_GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
-        RDFresult['MoRSE'+'U'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-def CalculateChargeMoRSE(ChargeCoordinates):
-    
-    """
-    #################################################################
-    The calculation of  3-D MoRse descriptors 
-    
-    based on atomic charge.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    charge=[]
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        charge.append(float(i[4]))
-    DM=_GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+charge[j]*charge[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
-        RDFresult['MoRSE'+'C'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-def CalculateMassMoRSE(mol,ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  3-D MoRse descriptors 
-    
-    based on atomic mass.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    mass=[i.atomicmass for i in mol.atoms]
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-    DM=_GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+mass[j]*mass[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
-        RDFresult['MoRSE'+'M'+str(kkk+1)]=round(res/144,3)
-        
-    return RDFresult    
-
-
-def CalculateAtomicNumberMoRSE(mol,ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  3-D MoRse descriptors 
-    
-    based on atomic number.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    mass=[i.atomicnum for i in mol.atoms]
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-    DM=_GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+mass[j]*mass[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
-        RDFresult['MoRSE'+'N'+str(kkk+1)]=round(res/144,3)
-        
-    return RDFresult       
-
-
-
-
-def CalculatePolarizabilityMoRSE(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  3-D MoRse descriptors 
-    
-    based on atomic polarizablity.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    polarizability=[]
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        polarizability.append(GetRelativeAtomicProperty(i[0],'alapha'))
-    DM=_GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+polarizability[j]*polarizability[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
-        RDFresult['MoRSE'+'P'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-
-def CalculateSandersonElectronegativityMoRSE(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  3-D MoRse descriptors 
-    
-    based on atomic sanderson electronegativity.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    En=[]
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        En.append(GetRelativeAtomicProperty(i[0],'En'))
-    DM=_GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+En[j]*En[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
-        RDFresult['MoRSE'+'E'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-
-def CalculateVDWVolumeMoRSE(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  3-D MoRse descriptors 
-    
-    based on atomic van der Waals volume.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    VDW=[]
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        VDW.append(GetRelativeAtomicProperty(i[0],'V'))
-    DM=_GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+VDW[j]*VDW[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
-        RDFresult['MoRSE'+'V'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-
-def GetMoRSEUnweighted(mol):
-    
-    """
-    #################################################################
-    Obtain all unweighted 3D-Morse descriptors .
-    #################################################################
-    """
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateUnweightMoRSE(ChargeCoordinates)
-    
-    return result
-
-
-def GetMoRSECharge(mol):
-    
-    """
-    #################################################################
-    Obtain all 3D-Morse descriptors baed on charge schems.
-    #################################################################
-    """
-
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateChargeMoRSE(ChargeCoordinates)
-    
-    return result
-
-    
-    
-def GetMoRSEMass(mol):
-    
-    """
-    #################################################################
-    Obtain all 3D-Morse descriptors baed on mass schems.
-    #################################################################
-    """
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateMassMoRSE(mol,ChargeCoordinates)
-    
-    return result
-
-
-
-    
-def GetMoRSEAtomicNumber(mol):
-    
-    """
-    #################################################################
-    Obtain all 3D-Morse descriptors baed on atomic number schems.
-    #################################################################
-    """
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateAtomicNumberMoRSE(mol,ChargeCoordinates)
-    
-    return result
-    
-    
-    
-    
-def GetMoRSEPolarizability(mol):
-    
-    """
-    #################################################################
-    Obtain all 3D-Morse descriptors baed on polarizability schems.
-    #################################################################
-    """
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculatePolarizabilityMoRSE(ChargeCoordinates)
-    
-    return result
-    
-    
-    
-def GetMoRSESandersonElectronegativity(mol):
-    
-    """
-    #################################################################
-    Obtain all 3D-Morse descriptors baed on Sanderson Electronegativity schems.
-    #################################################################
-    """
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateSandersonElectronegativityMoRSE(ChargeCoordinates)
-    
-    return result
-
-
-
-def GetMoRSEVDWVolume(mol):
-    
-    """
-    #################################################################
-    Obtain all 3D-Morse descriptors baed on VDW Volume schems.
-    #################################################################
-    """
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateVDWVolumeMoRSE(ChargeCoordinates)
-    
-    return result    
-    
-def GetMoRSE(mol):
-    
-    """
-    #################################################################
-    Obtain all 3D-Morse descriptors baed on different weighted schems.
-    #################################################################
-    """
-    result={}
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result.update(CalculateUnweightMoRSE(ChargeCoordinates))
-    result.update(CalculateChargeMoRSE(ChargeCoordinates))
-    result.update(CalculateMassMoRSE(mol,ChargeCoordinates))
-    result.update(CalculateAtomicNumberMoRSE(mol,ChargeCoordinates))
-    result.update(CalculatePolarizabilityMoRSE(ChargeCoordinates))
-    result.update(CalculateSandersonElectronegativityMoRSE(ChargeCoordinates))
-    result.update(CalculateVDWVolumeMoRSE(ChargeCoordinates))
-     
-    return result
-
-def _GetHTMLDoc():
-    """
-    #################################################################
-    Write HTML documentation for this module.
-    #################################################################
-    """
-    import pydoc
-    pydoc.writedoc('morse')
-############################################################################
-if __name__=="__main__":
-    
-
-    from GeoOpt import GetARCFile
-    mol='C1C=CCCS1'
-    inputmol=pybel.readstring('smi',mol)  
-    GetARCFile(inputmol)
-    #filename='temp'
-    ChargeCoordinates=_ReadCoordinates()
-    print CalculateVDWVolumeMoRSE(ChargeCoordinates)
-    print len(GetMoRSE(inputmol))
\ No newline at end of file
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+
+The calculation of 3D morse descriptors. You can get 210 molecular
+
+decriptors. You can freely use and distribute it. If you hava  
+
+any problem, you could contact with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.11.13
+
+Email: oriental-cds@163.com
+
+##############################################################################
+"""
+
+from .GeoOpt import _ReadCoordinates
+from .AtomProperty import GetRelativeAtomicProperty
+
+import pybel
+import scipy
+
+import math
+
+
+Version=1.0
+###set the parameters in RDF equation
+_beta=100
+
+def _GetR(n=32):
+    """
+    #################################################################
+    *Internal Use Only*
+    
+    Obtain the parameter R in RDF equation.
+    #################################################################
+    """
+    R=[]
+    for i in range(1,n+1):
+        R.append(float(i*1))
+    return R
+
+
+def _GetAtomDistance(x,y):
+    """
+    #################################################################
+    *Internal Use Only*
+    
+    Obtain the Elucidian distance based on the coordinates of two atoms
+    #################################################################
+    """
+
+    temp=[math.pow(x[0]-y[0],2),math.pow(x[1]-y[1],2),math.pow(x[2]-y[2],2)]
+    res=math.sqrt(sum(temp))
+    return res
+    
+
+def _GetGementricalDistanceMatrix(CoordinateList):
+    """
+    #################################################################
+    *Internal Use Only*
+    
+    Obtain the distance matrix of a molecule based on coordinate list
+    #################################################################
+    """
+    NAtom=len(CoordinateList)
+    DistanceMatrix=scipy.zeros((NAtom,NAtom))
+    for i in range(NAtom-1):
+        for j in range(i+1,NAtom):
+            DistanceMatrix[i,j]=_GetAtomDistance(CoordinateList[i],CoordinateList[j])
+            DistanceMatrix[j,i]=DistanceMatrix[i,j]
+    return DistanceMatrix
+
+    
+def CalculateUnweightMoRSE(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  unweighted 3-D MoRse descriptors 
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+#    ChargeCoordinates=_ReadCoordinates('temp.arc')
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        
+    DM=_GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
+        RDFresult['MoRSE'+'U'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+def CalculateChargeMoRSE(ChargeCoordinates):
+    
+    """
+    #################################################################
+    The calculation of  3-D MoRse descriptors 
+    
+    based on atomic charge.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    charge=[]
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        charge.append(float(i[4]))
+    DM=_GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+charge[j]*charge[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
+        RDFresult['MoRSE'+'C'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+def CalculateMassMoRSE(mol,ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  3-D MoRse descriptors 
+    
+    based on atomic mass.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    mass=[i.atomicmass for i in mol.atoms]
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+    DM=_GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+mass[j]*mass[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
+        RDFresult['MoRSE'+'M'+str(kkk+1)]=round(res/144,3)
+        
+    return RDFresult    
+
+
+def CalculateAtomicNumberMoRSE(mol,ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  3-D MoRse descriptors 
+    
+    based on atomic number.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    mass=[i.atomicnum for i in mol.atoms]
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+    DM=_GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+mass[j]*mass[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
+        RDFresult['MoRSE'+'N'+str(kkk+1)]=round(res/144,3)
+        
+    return RDFresult       
+
+
+
+
+def CalculatePolarizabilityMoRSE(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  3-D MoRse descriptors 
+    
+    based on atomic polarizablity.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    polarizability=[]
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        polarizability.append(GetRelativeAtomicProperty(i[0],'alapha'))
+    DM=_GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+polarizability[j]*polarizability[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
+        RDFresult['MoRSE'+'P'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+
+def CalculateSandersonElectronegativityMoRSE(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  3-D MoRse descriptors 
+    
+    based on atomic sanderson electronegativity.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    En=[]
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        En.append(GetRelativeAtomicProperty(i[0],'En'))
+    DM=_GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+En[j]*En[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
+        RDFresult['MoRSE'+'E'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+
+def CalculateVDWVolumeMoRSE(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  3-D MoRse descriptors 
+    
+    based on atomic van der Waals volume.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    VDW=[]
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        VDW.append(GetRelativeAtomicProperty(i[0],'V'))
+    DM=_GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+VDW[j]*VDW[k]*math.sin(Ri*DM[j,k])/(Ri*DM[j,k])
+        RDFresult['MoRSE'+'V'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+
+def GetMoRSEUnweighted(mol):
+    
+    """
+    #################################################################
+    Obtain all unweighted 3D-Morse descriptors .
+    #################################################################
+    """
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateUnweightMoRSE(ChargeCoordinates)
+    
+    return result
+
+
+def GetMoRSECharge(mol):
+    
+    """
+    #################################################################
+    Obtain all 3D-Morse descriptors baed on charge schems.
+    #################################################################
+    """
+
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateChargeMoRSE(ChargeCoordinates)
+    
+    return result
+
+    
+    
+def GetMoRSEMass(mol):
+    
+    """
+    #################################################################
+    Obtain all 3D-Morse descriptors baed on mass schems.
+    #################################################################
+    """
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateMassMoRSE(mol,ChargeCoordinates)
+    
+    return result
+
+
+
+    
+def GetMoRSEAtomicNumber(mol):
+    
+    """
+    #################################################################
+    Obtain all 3D-Morse descriptors baed on atomic number schems.
+    #################################################################
+    """
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateAtomicNumberMoRSE(mol,ChargeCoordinates)
+    
+    return result
+    
+    
+    
+    
+def GetMoRSEPolarizability(mol):
+    
+    """
+    #################################################################
+    Obtain all 3D-Morse descriptors baed on polarizability schems.
+    #################################################################
+    """
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculatePolarizabilityMoRSE(ChargeCoordinates)
+    
+    return result
+    
+    
+    
+def GetMoRSESandersonElectronegativity(mol):
+    
+    """
+    #################################################################
+    Obtain all 3D-Morse descriptors baed on Sanderson Electronegativity schems.
+    #################################################################
+    """
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateSandersonElectronegativityMoRSE(ChargeCoordinates)
+    
+    return result
+
+
+
+def GetMoRSEVDWVolume(mol):
+    
+    """
+    #################################################################
+    Obtain all 3D-Morse descriptors baed on VDW Volume schems.
+    #################################################################
+    """
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateVDWVolumeMoRSE(ChargeCoordinates)
+    
+    return result    
+    
+def GetMoRSE(mol):
+    
+    """
+    #################################################################
+    Obtain all 3D-Morse descriptors baed on different weighted schems.
+    #################################################################
+    """
+    result={}
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result.update(CalculateUnweightMoRSE(ChargeCoordinates))
+    result.update(CalculateChargeMoRSE(ChargeCoordinates))
+    result.update(CalculateMassMoRSE(mol,ChargeCoordinates))
+    result.update(CalculateAtomicNumberMoRSE(mol,ChargeCoordinates))
+    result.update(CalculatePolarizabilityMoRSE(ChargeCoordinates))
+    result.update(CalculateSandersonElectronegativityMoRSE(ChargeCoordinates))
+    result.update(CalculateVDWVolumeMoRSE(ChargeCoordinates))
+     
+    return result
+
+def _GetHTMLDoc():
+    """
+    #################################################################
+    Write HTML documentation for this module.
+    #################################################################
+    """
+    import pydoc
+    pydoc.writedoc('morse')
+############################################################################
+if __name__=="__main__":
+    
+
+    from GeoOpt import GetARCFile
+    mol='C1C=CCCS1'
+    inputmol=pybel.readstring('smi',mol)  
+    GetARCFile(inputmol)
+    #filename='temp'
+    ChargeCoordinates=_ReadCoordinates()
+    print(CalculateVDWVolumeMoRSE(ChargeCoordinates))
+    print(len(GetMoRSE(inputmol)))
diff -Naur pychem-1.0/src/pychem/pychem.py pychem-1.0.3/src/pychem/pychem.py
--- pychem-1.0/src/pychem/pychem.py	2012-11-17 05:48:01.000000000 -0800
+++ pychem-1.0.3/src/pychem/pychem.py	2017-03-06 11:03:44.684668416 -0800
@@ -19,29 +19,29 @@
 
-import getmol
-import kappa
-import charge
-import connectivity
-import constitution
-import estate
-import geary
-import moe
-import molproperty
-import moran
-import moreaubroto
-import topology
-import fingerprint
-import basak
-import cpsa
-import geometric
-import bcut
-import morse
-import rdf
-import whim
+from . import getmol
+from . import kappa
+from . import charge
+from . import connectivity
+from . import constitution
+from . import estate
+from . import geary
+from . import moe
+from . import molproperty
+from . import moran
+from . import moreaubroto
+from . import topology
+from . import fingerprint
+from . import basak
+from . import cpsa
+from . import geometric
+from . import bcut
+from . import morse
+from . import rdf
+from . import whim
 import pybel
 
 from rdkit import Chem
 import string
-from GeoOpt import GetARCFile
+from .GeoOpt import GetARCFile
 
 
 Version=1.0
@@ -758,35 +758,35 @@
     
     drugclass=PyChem2d()
     drugclass.ReadMolFromSmile("CCC1(c2ccccc2)C(=O)N(C)C(=N1)O")
-    print drugclass.GetKappa()
-    print len(drugclass.GetTopology())
-    print len(drugclass.GetBasak())
-    print len(drugclass.GetKappa())
-    print len(drugclass.GetConnectivity())
-    print len(drugclass.GetConstitution())
-    print len(drugclass.GetMoran())
-    print len(drugclass.GetMOE())
-    print len(drugclass.GetGeary())
-    print len(drugclass.GetMolProperty())
-    print len(drugclass.GetBcut())
-    print len(drugclass.GetEstate())
-    print len(drugclass.GetMoreauBroto())
-    print len(drugclass.GetCharge())
-    print len(drugclass.GetAllDescriptor())
-    print drugclass.GetAllDescriptor()
+    print(drugclass.GetKappa())
+    print(len(drugclass.GetTopology()))
+    print(len(drugclass.GetBasak()))
+    print(len(drugclass.GetKappa()))
+    print(len(drugclass.GetConnectivity()))
+    print(len(drugclass.GetConstitution()))
+    print(len(drugclass.GetMoran()))
+    print(len(drugclass.GetMOE()))
+    print(len(drugclass.GetGeary()))
+    print(len(drugclass.GetMolProperty()))
+    print(len(drugclass.GetBcut()))
+    print(len(drugclass.GetEstate()))
+    print(len(drugclass.GetMoreauBroto()))
+    print(len(drugclass.GetCharge()))
+    print(len(drugclass.GetAllDescriptor()))
+    print(drugclass.GetAllDescriptor())
 #    print drugclass.GetMolFromDrugbank(ID="DB00133")
     res=drugclass.GetFingerprint(FPName='Estate')
-    print res
+    print(res)
     
     ###############################
     drug=PyChem3d()
     molsmi=drug.GetMolFromDrugbank("DB00133")
-    print molsmi
+    print(molsmi)
     drug.ReadMol(molsmi,'smi')
-    print len(drug.GetGeometric())
-    print len(drug.GetCPSA())
-    print len(drug.GetMoRSE())
-    print len(drug.GetRDF())
-    print len(drug.GetWHIM())
-    print drug.GetAllDescriptor()
-    print len(drug.GetAllDescriptor())
+    print(len(drug.GetGeometric()))
+    print(len(drug.GetCPSA()))
+    print(len(drug.GetMoRSE()))
+    print(len(drug.GetRDF()))
+    print(len(drug.GetWHIM()))
+    print(drug.GetAllDescriptor())
+    print(len(drug.GetAllDescriptor()))
diff -Naur pychem-1.0/src/pychem/quanchem.py pychem-1.0.3/src/pychem/quanchem.py
--- pychem-1.0/src/pychem/quanchem.py	2012-11-12 22:20:31.000000000 -0800
+++ pychem-1.0.3/src/pychem/quanchem.py	2017-01-20 11:03:44.684668416 -0800
@@ -1,199 +1,199 @@
-# -*- coding: utf-8 -*-
-"""
-Created on Tue Apr 19 11:17:47 2011
-
-@author: Administrator
-"""
-import pybel
-import numpy
-import string
-
-###########################################################################
-
-def _GetMax(x):
-    
-    """
-    #################################################################
-    Get the maximal value of x.
-    
-    if x==[] then get 0.0
-    #################################################################
-    """
-    if x==[]:
-        return 0.0
-    else:
-        return max(x)
-        
-def _GetMin(x):
-    """
-    #################################################################
-    Get the minmal value of x.
-    
-    if x==[] then get 0.0
-    #################################################################
-    """
-    if x==[]:
-        return 0.0
-    else:
-        return min(x)
-
-#############################################################################
-def ReadFile(filename):
-    """
-    #################################################################
-    Read the basic quantum chemistry descriptors from the obtained .arc file.
-    #################################################################
-    """
-    
-    inputdict={}
-    f=file(filename,'r')
-    for line in f.readlines():
-        if line[10:27]=="HEAT OF FORMATION":
-            inputdict['Hf']=float(line[-18:-6])/96.4853 ##1ev=96.4853kj/mol
-        if line[10:22]=="TOTAL ENERGY":
-            inputdict['ET']=float(line[-16:-4])
-        if line[10:16]=="DIPOLE":
-            inputdict['mu']=float(line[-16:-7])
-        if line[10:28]=="HOMO LUMO ENERGIES":
-            inputdict['EHomo']=float(line[-7:-1])
-            inputdict['ELumo']=float(line[-19:-8])
-        #if line[10:26]=="MOLECULAR WEIGHT":
-        #    inputdict['Mw']=float(line[-12:-1])
-        #if line[10:20]=="COSMO AREA":
-        #    inputdict['CoArea']=float(line[-24:-17])
-        #if line[10:22]=="COSMO VOLUME":
-        #    inputdict['CoVolume']=float(line[-24:-17])
-    f.close()   
-    
-    return inputdict  
-    
-def _ReadCharge(filename):
-    """
-    #################################################################
-    Read the charge of each atom in .arc file
-    #################################################################
-    """
-    Charge=[]
-    
-    f=file(filename,'r')
-    templine=f.readlines()
-    f.close()
-    
-    for line in range(len(templine)):
-        if templine[line][-7:-1]=="CHARGE":
-            k=line
-            break
-        
-    for i in templine[k+4:len(templine)-1]:
-        temp=i.split()
-        Charge.append([string.strip(temp[0]),string.strip(temp[10])])
-
-        
-    return Charge    
-    
-    
-def GetChargeDescriptors(filename):
-    """
-    #################################################################
-    The calculation of charge descriptors. 
-    #################################################################
-    """
-
-    res={}
-    Htemp=[]
-    Ctemp=[]
-    Ntemp=[]
-    Otemp=[]
-    temp=[]   
-    Charge=_ReadCharge(filename)
-    for i in Charge:
-        temp.append(float(i[1]))
-        if i[0]=='H':
-            Htemp.append(float(i[1]))
-        if i[0]=='C':
-            Ctemp.append(float(i[1]))
-        if i[0]=='N':
-            Ntemp.append(float(i[1]))
-        if i[0]=='O':
-            Otemp.append(float(i[1]))
-            
-     
-    res['QHmax']=round(_GetMax(Htemp),3)
-    res['QCmax']=round(_GetMax(Ctemp),3)
-    res['QNmax']=round(_GetMax(Ntemp),3)
-    res['QOmax']=round(_GetMax(Otemp),3)
-    res['QHmin']=round(_GetMin(Htemp),3)
-    res['QCmin']=round(_GetMin(Ctemp),3)
-    res['QNmin']=round(_GetMin(Ntemp),3)
-    res['QOmin']=round(_GetMin(Otemp),3)
-    res['Qmax']=round(max(temp),3)
-    res['Qmin']=round(min(temp),3)
-    res['QHss']=round(sum([i*i for i in Htemp]),3)
-    res['QCss']=round(sum([i*i for i in Ctemp]),3)
-    res['QNss']=round(sum([i*i for i in Ntemp]),3)
-    res['QOss']=round(sum([i*i for i in Otemp]),3)
-    res['Qass']=round(sum([i*i for i in temp]),3)
-    res['Mpc']=round(numpy.mean([i for i in temp if i>0]),3)
-    res['Tpc']=round(sum([i for i in temp if i>0]),3)
-    res['Mnc']=round(numpy.mean([i for i in temp if i<0]),3)
-    res['Tnc']=round(sum([i for i in temp if i<0]),3)
-    res['Tac']=round(sum([numpy.abs(i) for i in temp]),3)
-    res['Mac']=round(numpy.mean([numpy.abs(i) for i in temp]),3)
-    res['Rpc']=round(_GetMax(temp)/res['Tpc'],3)
-    res['Rnc']=round(_GetMin(temp)/res['Tnc'],3)
-    
-    return res
-    
-def CalculateBasicQC(inputdict):
-    """
-    #################################################################
-    Calculate the quantum chemical descriptors based on
-    
-    Lumo, Homo, dipole moment, enthalpy and the total energy.
-    
-    Note that the output is a dictionary type.
-    #################################################################
-    """
-    ##converting the unit into suitable one
-    EHomo=inputdict['EHomo']
-    ELumo=inputdict['ELumo']
-
-    
-    dict={}
-    dict.update(inputdict)
-    dict['GAP']=ELumo-EHomo
-    dict['S']=2./(ELumo-EHomo)
-    dict['eta']=(ELumo-EHomo)/2.0
-    dict['fHL']=EHomo/ELumo
-    dict['IP']=-EHomo
-    dict['EA']=-ELumo
-    dict['xmu']=(-ELumo-EHomo)/2.0
-    
-    return dict
-
-#############################################################################
-
-def GetQuantumChemistry():
-    """
-    #################################################################
-    Wrapper for quantum chemistry descriptors
-    #################################################################
-    """
-    filename='temp'
-    inputdict=ReadFile(filename)
-    #res=CalculateBasicQC(inputdict)
-    res={}
-    res.update(GetChargeDescriptors(filename))
-    
-    return res
-#############################################################################
-
-if __name__=="__main__":
-    
-    from GeoOpt import GetARCFile
-    mol='CC(N)C(=O)O'
-    inputmol=pybel.readstring('smi',mol)  
-    GetARCFile(inputmol)
-    result=GetQuantumChemistry()
-    print result
-    print len(result)
\ No newline at end of file
+# -*- coding: utf-8 -*-
+"""
+Created on Tue Apr 19 11:17:47 2011
+
+@author: Administrator
+"""
+import pybel
+import numpy
+import string
+
+###########################################################################
+
+def _GetMax(x):
+    
+    """
+    #################################################################
+    Get the maximal value of x.
+    
+    if x==[] then get 0.0
+    #################################################################
+    """
+    if x==[]:
+        return 0.0
+    else:
+        return max(x)
+        
+def _GetMin(x):
+    """
+    #################################################################
+    Get the minmal value of x.
+    
+    if x==[] then get 0.0
+    #################################################################
+    """
+    if x==[]:
+        return 0.0
+    else:
+        return min(x)
+
+#############################################################################
+def ReadFile(filename):
+    """
+    #################################################################
+    Read the basic quantum chemistry descriptors from the obtained .arc file.
+    #################################################################
+    """
+    
+    inputdict={}
+    f=file(filename,'r')
+    for line in f.readlines():
+        if line[10:27]=="HEAT OF FORMATION":
+            inputdict['Hf']=float(line[-18:-6])/96.4853 ##1ev=96.4853kj/mol
+        if line[10:22]=="TOTAL ENERGY":
+            inputdict['ET']=float(line[-16:-4])
+        if line[10:16]=="DIPOLE":
+            inputdict['mu']=float(line[-16:-7])
+        if line[10:28]=="HOMO LUMO ENERGIES":
+            inputdict['EHomo']=float(line[-7:-1])
+            inputdict['ELumo']=float(line[-19:-8])
+        #if line[10:26]=="MOLECULAR WEIGHT":
+        #    inputdict['Mw']=float(line[-12:-1])
+        #if line[10:20]=="COSMO AREA":
+        #    inputdict['CoArea']=float(line[-24:-17])
+        #if line[10:22]=="COSMO VOLUME":
+        #    inputdict['CoVolume']=float(line[-24:-17])
+    f.close()   
+    
+    return inputdict  
+    
+def _ReadCharge(filename):
+    """
+    #################################################################
+    Read the charge of each atom in .arc file
+    #################################################################
+    """
+    Charge=[]
+    
+    f=file(filename,'r')
+    templine=f.readlines()
+    f.close()
+    
+    for line in range(len(templine)):
+        if templine[line][-7:-1]=="CHARGE":
+            k=line
+            break
+        
+    for i in templine[k+4:len(templine)-1]:
+        temp=i.split()
+        Charge.append([string.strip(temp[0]),string.strip(temp[10])])
+
+        
+    return Charge    
+    
+    
+def GetChargeDescriptors(filename):
+    """
+    #################################################################
+    The calculation of charge descriptors. 
+    #################################################################
+    """
+
+    res={}
+    Htemp=[]
+    Ctemp=[]
+    Ntemp=[]
+    Otemp=[]
+    temp=[]   
+    Charge=_ReadCharge(filename)
+    for i in Charge:
+        temp.append(float(i[1]))
+        if i[0]=='H':
+            Htemp.append(float(i[1]))
+        if i[0]=='C':
+            Ctemp.append(float(i[1]))
+        if i[0]=='N':
+            Ntemp.append(float(i[1]))
+        if i[0]=='O':
+            Otemp.append(float(i[1]))
+            
+     
+    res['QHmax']=round(_GetMax(Htemp),3)
+    res['QCmax']=round(_GetMax(Ctemp),3)
+    res['QNmax']=round(_GetMax(Ntemp),3)
+    res['QOmax']=round(_GetMax(Otemp),3)
+    res['QHmin']=round(_GetMin(Htemp),3)
+    res['QCmin']=round(_GetMin(Ctemp),3)
+    res['QNmin']=round(_GetMin(Ntemp),3)
+    res['QOmin']=round(_GetMin(Otemp),3)
+    res['Qmax']=round(max(temp),3)
+    res['Qmin']=round(min(temp),3)
+    res['QHss']=round(sum([i*i for i in Htemp]),3)
+    res['QCss']=round(sum([i*i for i in Ctemp]),3)
+    res['QNss']=round(sum([i*i for i in Ntemp]),3)
+    res['QOss']=round(sum([i*i for i in Otemp]),3)
+    res['Qass']=round(sum([i*i for i in temp]),3)
+    res['Mpc']=round(numpy.mean([i for i in temp if i>0]),3)
+    res['Tpc']=round(sum([i for i in temp if i>0]),3)
+    res['Mnc']=round(numpy.mean([i for i in temp if i<0]),3)
+    res['Tnc']=round(sum([i for i in temp if i<0]),3)
+    res['Tac']=round(sum([numpy.abs(i) for i in temp]),3)
+    res['Mac']=round(numpy.mean([numpy.abs(i) for i in temp]),3)
+    res['Rpc']=round(_GetMax(temp)/res['Tpc'],3)
+    res['Rnc']=round(_GetMin(temp)/res['Tnc'],3)
+    
+    return res
+    
+def CalculateBasicQC(inputdict):
+    """
+    #################################################################
+    Calculate the quantum chemical descriptors based on
+    
+    Lumo, Homo, dipole moment, enthalpy and the total energy.
+    
+    Note that the output is a dictionary type.
+    #################################################################
+    """
+    ##converting the unit into suitable one
+    EHomo=inputdict['EHomo']
+    ELumo=inputdict['ELumo']
+
+    
+    dict={}
+    dict.update(inputdict)
+    dict['GAP']=ELumo-EHomo
+    dict['S']=2./(ELumo-EHomo)
+    dict['eta']=(ELumo-EHomo)/2.0
+    dict['fHL']=EHomo/ELumo
+    dict['IP']=-EHomo
+    dict['EA']=-ELumo
+    dict['xmu']=(-ELumo-EHomo)/2.0
+    
+    return dict
+
+#############################################################################
+
+def GetQuantumChemistry():
+    """
+    #################################################################
+    Wrapper for quantum chemistry descriptors
+    #################################################################
+    """
+    filename='temp'
+    inputdict=ReadFile(filename)
+    #res=CalculateBasicQC(inputdict)
+    res={}
+    res.update(GetChargeDescriptors(filename))
+    
+    return res
+#############################################################################
+
+if __name__=="__main__":
+    
+    from .GeoOpt import GetARCFile
+    mol='CC(N)C(=O)O'
+    inputmol=pybel.readstring('smi',mol)  
+    GetARCFile(inputmol)
+    result=GetQuantumChemistry()
+    print(result)
+    print(len(result))
diff -Naur pychem-1.0/src/pychem/radius.py pychem-1.0.3/src/pychem/radius.py
--- pychem-1.0/src/pychem/radius.py	2011-04-09 21:05:22.000000000 -0700
+++ pychem-1.0.3/src/pychem/radius.py	2017-01-20 11:03:44.684668416 -0800
@@ -30,4 +30,4 @@
  'AU': 1.8,
  'LI': 1.8,
  '.': 1.8
-}
\ No newline at end of file
+}
diff -Naur pychem-1.0/src/pychem/rdf.py pychem-1.0.3/src/pychem/rdf.py
--- pychem-1.0/src/pychem/rdf.py	2012-11-14 05:50:07.000000000 -0800
+++ pychem-1.0.3/src/pychem/rdf.py	2017-01-20 11:03:44.684668416 -0800
@@ -1,408 +1,408 @@
-# -*- coding: utf-8 -*-
-"""
-##############################################################################
-
-The calculation of 3D RDF descriptors. You can get 180 molecular
-
-decriptors. You can freely use and distribute it. If you hava  
-
-any problem, you could contact with us timely!
-
-Authors: Dongsheng Cao and Yizeng Liang.
-
-Date: 2012.11.13
-
-Email: oriental-cds@163.com
-
-##############################################################################
-"""
-
-from GeoOpt import _ReadCoordinates
-from AtomProperty import GetRelativeAtomicProperty
-import scipy
-import math
-
-
-Version=1.0
-#########################################################################
-###set the parameters in RDF equation
-_beta=100
-#########################################################################
-
-def _GetR(n=30):
-    """
-    #################################################################
-    Obtain the parameter R in RDF equation.
-    #################################################################
-    """
-    R=[]
-    for i in range(2,n+2):
-        R.append(float(i*0.5))
-    return R
-
-
-def GetAtomDistance(x,y):
-    """
-    #################################################################
-    Obtain the Elucidian distance based on the 
-    
-    coordinates of two atoms
-    #################################################################
-    """
-
-    temp=[math.pow(x[0]-y[0],2),math.pow(x[1]-y[1],2),math.pow(x[2]-y[2],2)]
-    res=math.sqrt(sum(temp))
-    return res
-    
-
-def GetGementricalDistanceMatrix(CoordinateList):
-    """
-    #################################################################
-    Obtain the distance matrix of a molecule based 
-    
-    on coordinate list
-    #################################################################
-    """
-    NAtom=len(CoordinateList)
-    DistanceMatrix=scipy.zeros((NAtom,NAtom))
-    for i in range(NAtom-1):
-        for j in range(i+1,NAtom):
-            DistanceMatrix[i,j]=GetAtomDistance(CoordinateList[i],CoordinateList[j])
-            DistanceMatrix[j,i]=DistanceMatrix[i,j]
-    return DistanceMatrix
-
-    
-def CalculateUnweightRDF(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of unweighted radial distribution 
-    
-    function (RDF) descriptors.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-#    ChargeCoordinates=_ReadCoordinates('temp.arc')
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        
-    DM=GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+math.exp(-_beta*math.pow(Ri-DM[j,k],2))
-        RDFresult['RDF'+'U'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-def CalculateChargeRDF(ChargeCoordinates):
-    
-    """
-    #################################################################
-    The calculation of  radial distribution function 
-    
-    (RDF) descriptors based on atomic charge.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    Charge=[]
-#    ChargeCoordinates=_ReadCoordinates('temp.arc')
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        Charge.append(float(i[4]))
-        
-    DM=GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+Charge[j]*Charge[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
-        RDFresult['RDF'+'C'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-def CalculateMassRDF(mol,ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of radial distribution function (RDF) 
-    
-    descriptors based on atomic mass.
-    #################################################################
-    """
-    mol.addh()
-    mass=[i.atomicmass for i in mol.atoms]
-    R=_GetR(n=30)
-    temp=[]
-#    ChargeCoordinates=_ReadCoordinates('temp.arc')
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        
-    DM=GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+mass[j]*mass[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
-        RDFresult['RDF'+'M'+str(kkk+1)]=round(res/144,3)
-        
-    return RDFresult
- 
-        
-
-def CalculatePolarizabilityRDF(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  radial distribution function 
-    
-    (RDF) descriptors based on atomic polarizability.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    polarizability=[]
-#    ChargeCoordinates=_ReadCoordinates('temp.arc')
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        polarizability.append(GetRelativeAtomicProperty(i[0],'alapha'))
-        
-    DM=GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+polarizability[j]*polarizability[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
-        RDFresult['RDF'+'P'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-
-def CalculateSandersonElectronegativityRDF(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  radial distribution function 
-    
-    (RDF) descriptors based on atomic electronegativity.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    EN=[]
-#    ChargeCoordinates=_ReadCoordinates('temp.arc')
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        EN.append(GetRelativeAtomicProperty(i[0],'En'))
-        
-    DM=GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+EN[j]*EN[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
-        RDFresult['RDF'+'E'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-def CalculateVDWVolumeRDF(ChargeCoordinates):
-    """
-    #################################################################
-    The calculation of  radial distribution function 
-    
-    (RDF) descriptors based on atomic van der Waals volume.
-    #################################################################
-    """
-    R=_GetR(n=30)
-    temp=[]
-    VDW=[]
-#    ChargeCoordinates=_ReadCoordinates('temp.arc')
-    for i in ChargeCoordinates:
-        #if i[0]!='H':
-        temp.append([float(i[1]),float(i[2]),float(i[3])])
-        VDW.append(GetRelativeAtomicProperty(i[0],'V'))
-        
-    DM=GetGementricalDistanceMatrix(temp)
-    nAT=len(temp)
-    RDFresult={}
-    
-    for kkk,Ri in enumerate(R):        
-        res=0.0
-        for j in range(nAT-1):
-            for k in range(j+1,nAT):
-                res=res+VDW[j]*VDW[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
-        RDFresult['RDF'+'V'+str(kkk+1)]=round(res,3)
-        
-    return RDFresult
-
-
-
-def GetRDFUnweighed(mol):
-    
-    """
-    #################################################################
-    Obtain all Unweighed radial distribution function descriptors.
-    #################################################################
-    """
-
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateUnweightRDF(ChargeCoordinates)
-     
-    return result
-
-
-
-def GetRDFCharge(mol):
-    
-    """
-    #################################################################
-    Obtain all radial distribution function descriptors based 
-    
-    on Charge schems.
-    #################################################################
-    """
-
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateChargeRDF(ChargeCoordinates)
-     
-    return result
-    
-    
-def GetRDFMass(mol):
-    
-    """
-    #################################################################
-    Obtain all radial distribution function descriptors based 
-    
-    on Mass schems.
-    #################################################################
-    """
-
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateMassRDF(mol,ChargeCoordinates)
-     
-    return result
-    
-    
-def GetRDFPolarizability(mol):
-    
-    """
-    #################################################################
-    Obtain all radial distribution function descriptors based 
-    
-    on Polarizability schems.
-    #################################################################
-    """
-
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculatePolarizabilityRDF(ChargeCoordinates)
-     
-    return result
-
-
-
-def GetRDFSandersonElectronegativity(mol):
-    
-    """
-    #################################################################
-    Obtain all radial distribution function descriptors based 
-    
-    onSanderson Electronegativity schems.
-    #################################################################
-    """
-
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateSandersonElectronegativityRDF(ChargeCoordinates)
-     
-    return result
-
-
-def GetRDFVDWVolume(mol):
-    
-    """
-    #################################################################
-    Obtain all radial distribution function descriptors based 
-    
-    on VDW Volume schems.
-    #################################################################
-    """
-
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result=CalculateVDWVolumeRDF(ChargeCoordinates)
-     
-    return result
-
-
-
-def GetRDF(mol):
-    
-    """
-    #################################################################
-    Obtain all radial distribution function descriptors based 
-    
-    on different weighted schems.
-    #################################################################
-    """
-    result={}
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename) 
-    result.update(CalculateUnweightRDF(ChargeCoordinates))
-    result.update(CalculateChargeRDF(ChargeCoordinates))
-    result.update(CalculateMassRDF(mol,ChargeCoordinates))
-    result.update(CalculatePolarizabilityRDF(ChargeCoordinates))
-    result.update(CalculateSandersonElectronegativityRDF(ChargeCoordinates))
-    result.update(CalculateVDWVolumeRDF(ChargeCoordinates))
-     
-    return result
-
-
-def _GetHTMLDoc():
-    """
-    #################################################################
-    Write HTML documentation for this module.
-    #################################################################
-    """
-    import pydoc
-    pydoc.writedoc('rdf')
-############################################################################
-if __name__=="__main__":
-
-    import pybel
-    from GeoOpt import GetARCFile
-    mol='C1C=CCCS1'
-    inputmol=pybel.readstring('smi',mol)  
-    GetARCFile(inputmol)
-    filename='temp'
-    ChargeCoordinates=_ReadCoordinates(filename)
-    res=CalculateVDWVolumeRDF(ChargeCoordinates)
-    print res
-    print len(GetRDF(inputmol))
-    
+# -*- coding: utf-8 -*-
+"""
+##############################################################################
+
+The calculation of 3D RDF descriptors. You can get 180 molecular
+
+decriptors. You can freely use and distribute it. If you hava  
+
+any problem, you could contact with us timely!
+
+Authors: Dongsheng Cao and Yizeng Liang.
+
+Date: 2012.11.13
+
+Email: oriental-cds@163.com
+
+##############################################################################
+"""
+
+from .GeoOpt import _ReadCoordinates
+from .AtomProperty import GetRelativeAtomicProperty
+import scipy
+import math
+
+
+Version=1.0
+#########################################################################
+###set the parameters in RDF equation
+_beta=100
+#########################################################################
+
+def _GetR(n=30):
+    """
+    #################################################################
+    Obtain the parameter R in RDF equation.
+    #################################################################
+    """
+    R=[]
+    for i in range(2,n+2):
+        R.append(float(i*0.5))
+    return R
+
+
+def GetAtomDistance(x,y):
+    """
+    #################################################################
+    Obtain the Elucidian distance based on the 
+    
+    coordinates of two atoms
+    #################################################################
+    """
+
+    temp=[math.pow(x[0]-y[0],2),math.pow(x[1]-y[1],2),math.pow(x[2]-y[2],2)]
+    res=math.sqrt(sum(temp))
+    return res
+    
+
+def GetGementricalDistanceMatrix(CoordinateList):
+    """
+    #################################################################
+    Obtain the distance matrix of a molecule based 
+    
+    on coordinate list
+    #################################################################
+    """
+    NAtom=len(CoordinateList)
+    DistanceMatrix=scipy.zeros((NAtom,NAtom))
+    for i in range(NAtom-1):
+        for j in range(i+1,NAtom):
+            DistanceMatrix[i,j]=GetAtomDistance(CoordinateList[i],CoordinateList[j])
+            DistanceMatrix[j,i]=DistanceMatrix[i,j]
+    return DistanceMatrix
+
+    
+def CalculateUnweightRDF(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of unweighted radial distribution 
+    
+    function (RDF) descriptors.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+#    ChargeCoordinates=_ReadCoordinates('temp.arc')
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        
+    DM=GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+math.exp(-_beta*math.pow(Ri-DM[j,k],2))
+        RDFresult['RDF'+'U'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+def CalculateChargeRDF(ChargeCoordinates):
+    
+    """
+    #################################################################
+    The calculation of  radial distribution function 
+    
+    (RDF) descriptors based on atomic charge.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    Charge=[]
+#    ChargeCoordinates=_ReadCoordinates('temp.arc')
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        Charge.append(float(i[4]))
+        
+    DM=GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+Charge[j]*Charge[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
+        RDFresult['RDF'+'C'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+def CalculateMassRDF(mol,ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of radial distribution function (RDF) 
+    
+    descriptors based on atomic mass.
+    #################################################################
+    """
+    mol.addh()
+    mass=[i.atomicmass for i in mol.atoms]
+    R=_GetR(n=30)
+    temp=[]
+#    ChargeCoordinates=_ReadCoordinates('temp.arc')
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        
+    DM=GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+mass[j]*mass[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
+        RDFresult['RDF'+'M'+str(kkk+1)]=round(res/144,3)
+        
+    return RDFresult
+ 
+        
+
+def CalculatePolarizabilityRDF(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  radial distribution function 
+    
+    (RDF) descriptors based on atomic polarizability.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    polarizability=[]
+#    ChargeCoordinates=_ReadCoordinates('temp.arc')
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        polarizability.append(GetRelativeAtomicProperty(i[0],'alapha'))
+        
+    DM=GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+polarizability[j]*polarizability[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
+        RDFresult['RDF'+'P'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+
+def CalculateSandersonElectronegativityRDF(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  radial distribution function 
+    
+    (RDF) descriptors based on atomic electronegativity.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    EN=[]
+#    ChargeCoordinates=_ReadCoordinates('temp.arc')
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        EN.append(GetRelativeAtomicProperty(i[0],'En'))
+        
+    DM=GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+EN[j]*EN[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
+        RDFresult['RDF'+'E'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+def CalculateVDWVolumeRDF(ChargeCoordinates):
+    """
+    #################################################################
+    The calculation of  radial distribution function 
+    
+    (RDF) descriptors based on atomic van der Waals volume.
+    #################################################################
+    """
+    R=_GetR(n=30)
+    temp=[]
+    VDW=[]
+#    ChargeCoordinates=_ReadCoordinates('temp.arc')
+    for i in ChargeCoordinates:
+        #if i[0]!='H':
+        temp.append([float(i[1]),float(i[2]),float(i[3])])
+        VDW.append(GetRelativeAtomicProperty(i[0],'V'))
+        
+    DM=GetGementricalDistanceMatrix(temp)
+    nAT=len(temp)
+    RDFresult={}
+    
+    for kkk,Ri in enumerate(R):        
+        res=0.0
+        for j in range(nAT-1):
+            for k in range(j+1,nAT):
+                res=res+VDW[j]*VDW[k]*math.exp(-_beta*math.pow(Ri-DM[j,k],2))
+        RDFresult['RDF'+'V'+str(kkk+1)]=round(res,3)
+        
+    return RDFresult
+
+
+
+def GetRDFUnweighed(mol):
+    
+    """
+    #################################################################
+    Obtain all Unweighed radial distribution function descriptors.
+    #################################################################
+    """
+
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateUnweightRDF(ChargeCoordinates)
+     
+    return result
+
+
+
+def GetRDFCharge(mol):
+    
+    """
+    #################################################################
+    Obtain all radial distribution function descriptors based 
+    
+    on Charge schems.
+    #################################################################
+    """
+
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateChargeRDF(ChargeCoordinates)
+     
+    return result
+    
+    
+def GetRDFMass(mol):
+    
+    """
+    #################################################################
+    Obtain all radial distribution function descriptors based 
+    
+    on Mass schems.
+    #################################################################
+    """
+
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateMassRDF(mol,ChargeCoordinates)
+     
+    return result
+    
+    
+def GetRDFPolarizability(mol):
+    
+    """
+    #################################################################
+    Obtain all radial distribution function descriptors based 
+    
+    on Polarizability schems.
+    #################################################################
+    """
+
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculatePolarizabilityRDF(ChargeCoordinates)
+     
+    return result
+
+
+
+def GetRDFSandersonElectronegativity(mol):
+    
+    """
+    #################################################################
+    Obtain all radial distribution function descriptors based 
+    
+    onSanderson Electronegativity schems.
+    #################################################################
+    """
+
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateSandersonElectronegativityRDF(ChargeCoordinates)
+     
+    return result
+
+
+def GetRDFVDWVolume(mol):
+    
+    """
+    #################################################################
+    Obtain all radial distribution function descriptors based 
+    
+    on VDW Volume schems.
+    #################################################################
+    """
+
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result=CalculateVDWVolumeRDF(ChargeCoordinates)
+     
+    return result
+
+
+
+def GetRDF(mol):
+    
+    """
+    #################################################################
+    Obtain all radial distribution function descriptors based 
+    
+    on different weighted schems.
+    #################################################################
+    """
+    result={}
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename) 
+    result.update(CalculateUnweightRDF(ChargeCoordinates))
+    result.update(CalculateChargeRDF(ChargeCoordinates))
+    result.update(CalculateMassRDF(mol,ChargeCoordinates))
+    result.update(CalculatePolarizabilityRDF(ChargeCoordinates))
+    result.update(CalculateSandersonElectronegativityRDF(ChargeCoordinates))
+    result.update(CalculateVDWVolumeRDF(ChargeCoordinates))
+     
+    return result
+
+
+def _GetHTMLDoc():
+    """
+    #################################################################
+    Write HTML documentation for this module.
+    #################################################################
+    """
+    import pydoc
+    pydoc.writedoc('rdf')
+############################################################################
+if __name__=="__main__":
+
+    import pybel
+    from .GeoOpt import GetARCFile
+    mol='C1C=CCCS1'
+    inputmol=pybel.readstring('smi',mol)  
+    GetARCFile(inputmol)
+    filename='temp'
+    ChargeCoordinates=_ReadCoordinates(filename)
+    res=CalculateVDWVolumeRDF(ChargeCoordinates)
+    print(res)
+    print(len(GetRDF(inputmol)))
+    
diff -Naur pychem-1.0/src/pychem/topology.py pychem-1.0.3/src/pychem/topology.py
--- pychem-1.0/src/pychem/topology.py	2012-11-14 05:41:48.000000000 -0800
+++ pychem-1.0.3/src/pychem/topology.py	2017-01-20 11:03:44.684668416 -0800
@@ -1110,8 +1110,8 @@
     smis = ['CCCC','CCCCC','CCCCCC','CC(N)C(=O)O','CC(N)C(=O)[O-]']
     for index, smi in enumerate(smis):
         m = Chem.MolFromSmiles(smi)
-        print index+1
-        print smi      
-        print '\t',GetTopology(m)
-        print '\t',len(GetTopology(m))
+        print(index+1)
+        print(smi)      
+        print('\t',GetTopology(m))
+        print('\t',len(GetTopology(m)))
 
diff -Naur pychem-1.0/src/pychem/vector3d.py pychem-1.0.3/src/pychem/vector3d.py
--- pychem-1.0/src/pychem/vector3d.py	2007-11-22 23:24:26.000000000 -0800
+++ pychem-1.0.3/src/pychem/vector3d.py	2017-01-20 11:03:44.684668416 -0800
@@ -277,7 +277,7 @@
     for i in range(0, 3):
       for j in range(0, 3):
         if abs(self.elem(i,j) - rhs.elem(i,j)) > SMALL:
-	      return False
+          return False
     return True
 	
   def __mul__(self, rhs):
diff -Naur pychem-1.0/src/pychem/whim.py pychem-1.0.3/src/pychem/whim.py
--- pychem-1.0/src/pychem/whim.py	2012-11-16 22:55:59.000000000 -0800
+++ pychem-1.0.3/src/pychem/whim.py	2017-01-20 11:03:44.684668416 -0800
@@ -19,8 +19,8 @@
 import pybel
 import scipy
 import scipy.linalg
-from GeoOpt import _ReadCoordinates
-from AtomProperty import GetRelativeAtomicProperty
+from .GeoOpt import _ReadCoordinates
+from .AtomProperty import GetRelativeAtomicProperty
 
 
 
@@ -576,10 +576,10 @@
 #############################################################################
 if __name__=="__main__":
 
-    from GeoOpt import GetARCFile
+    from .GeoOpt import GetARCFile
     mol='c1ccccc1N'
     inputmol=pybel.readstring('smi',mol)  
     GetARCFile(inputmol)
     result=GetWHIMSandersonElectronegativity()
-    print result
-    print len(result)
\ No newline at end of file
+    print(result)
+    print(len(result))
